<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>PHP7内存管理 - 杨航博客</title><meta description="内存管理的意义：内存是系统中重要的基本资源之一，内存的管理是指其分配、使用和回收的管理；保障各个程序内存的正常分配和回收。   虽然操作系统以及提供了一套内存管理的函数，但是PHP还是自己实现了一套内存管理方案-PHP内存管理器（Zend Memory Manager简称MM）如下图："><meta property="og:type" content="article"><meta property="og:title" content="PHP7内存管理"><meta property="og:url" content="https://april2nd.github.io/"><meta property="og:site_name" content="杨航博客"><meta property="og:description" content="内存管理的意义：内存是系统中重要的基本资源之一，内存的管理是指其分配、使用和回收的管理；保障各个程序内存的正常分配和回收。   虽然操作系统以及提供了一套内存管理的函数，但是PHP还是自己实现了一套内存管理方案-PHP内存管理器（Zend Memory Manager简称MM）如下图："><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://ww1.sinaimg.cn/large/98f40ff8ly1gdiosxrsrjj20uq0tcmzc.jpg"><meta property="og:image" content="http://ww1.sinaimg.cn/large/98f40ff8ly1gdiq5g0qh1j214g0a0q3w.jpg"><meta property="og:image" content="http://ww1.sinaimg.cn/large/98f40ff8ly1gdirezxr4hj20i60gg75l.jpg"><meta property="og:image" content="http://ww1.sinaimg.cn/large/98f40ff8ly1gdj56xomjbj215408maau.jpg"><meta property="og:image" content="http://ww1.sinaimg.cn/large/98f40ff8ly1gdj58wrdqcj215g0omtef.jpg"><meta property="og:image" content="http://ww1.sinaimg.cn/large/98f40ff8ly1gdj5aq2lnzj215c086ab9.jpg"><meta property="og:image" content="http://ww1.sinaimg.cn/large/98f40ff8ly1gdj5jv462gj212s0q60xa.jpg"><meta property="article:published_time" content="2020-04-05T02:01:07.000Z"><meta property="article:modified_time" content="2020-04-05T12:32:05.655Z"><meta property="article:author" content="杨航"><meta property="article:tag" content="PHP"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://ww1.sinaimg.cn/large/98f40ff8ly1gdiosxrsrjj20uq0tcmzc.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://april2nd.github.io/2020/04/05/PHP7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},"headline":"杨航博客","image":["http://ww1.sinaimg.cn/large/98f40ff8ly1gdiosxrsrjj20uq0tcmzc.jpg","http://ww1.sinaimg.cn/large/98f40ff8ly1gdiq5g0qh1j214g0a0q3w.jpg","http://ww1.sinaimg.cn/large/98f40ff8ly1gdirezxr4hj20i60gg75l.jpg","http://ww1.sinaimg.cn/large/98f40ff8ly1gdj56xomjbj215408maau.jpg","http://ww1.sinaimg.cn/large/98f40ff8ly1gdj58wrdqcj215g0omtef.jpg","http://ww1.sinaimg.cn/large/98f40ff8ly1gdj5aq2lnzj215c086ab9.jpg","http://ww1.sinaimg.cn/large/98f40ff8ly1gdj5jv462gj212s0q60xa.jpg"],"datePublished":"2020-04-05T02:01:07.000Z","dateModified":"2020-04-05T12:32:05.655Z","author":{"@type":"Person","name":"杨航"},"description":"内存管理的意义：内存是系统中重要的基本资源之一，内存的管理是指其分配、使用和回收的管理；保障各个程序内存的正常分配和回收。   虽然操作系统以及提供了一套内存管理的函数，但是PHP还是自己实现了一套内存管理方案-PHP内存管理器（Zend Memory Manager简称MM）如下图："}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logos.svg" alt="杨航博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about/">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/april2nd"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-05T02:01:07.000Z" title="2020-04-05T02:01:07.000Z">2020-04-05</time><span class="level-item"><a class="link-muted" href="/categories/PHP/">PHP</a></span><span class="level-item">31 分钟 读完 (大约 4650 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">PHP7内存管理</h1><div class="content"><blockquote>
<p>内存管理的意义：内存是系统中重要的基本资源之一，内存的管理是指其分配、使用和回收的管理；保障各个程序内存的正常分配和回收。</p>
</blockquote>
<p> 虽然操作系统以及提供了一套内存管理的函数，但是PHP还是自己实现了一套内存管理方案-PHP内存管理器（Zend Memory Manager简称MM）如下图：</p>
<a id="more"></a>
<p><img src="http://ww1.sinaimg.cn/large/98f40ff8ly1gdiosxrsrjj20uq0tcmzc.jpg" alt="PHP7内存管理器示意图"></p>
<p>从图中可以看出PHP脚本运行所需内存不是直接从系统调用的，而是先通过内存管理器提供的一系列API接口（zend-mm-alloc-small、alloc-large、alloc-huge等，alloc意思为分配，huge为超大）申请：如果MM中有足够的内存，则直接分配给脚本；如果MM中不够用，则MM再向系统申请。这样可以有效减少PHP向系统调用的次数，并且优化内存空间使用效率。因为C、C++需要手动申请和释放内存，所以其比PHP开发要难。</p>
<blockquote>
<p>在此引入一个内存池的概念：提供了一个更有效率的解决方案，即预先规划一定数量的内存区块，使得整个程序可以在运行期规划（allocate）、使用（access）、归还（free）内存区块。一个池子无非就是先占用一块内存，然后给需要的人使用。</p>
</blockquote>
<hr>
<h1 id="内存管理准备知识"><a href="#内存管理准备知识" class="headerlink" title="内存管理准备知识"></a>内存管理准备知识</h1><p>据PHP 7核心开发者描述，PHP 7在内存管理上的CPU时间节省达到了21%，提升巨大。</p>
<p>PH7其实是借鉴了前辈的内存管理方案：jemalloc和tcmalloc，这两个分别是火狐和chrome两大浏览器的内存管理器。这种内存管理器的内存分配思想大致就是：先申请一大块内存，自己先占着，然后再按照大中小三种规格分割成小块，放在内存池中。当程序申请内存时，MM从池子中挑选合适大小的内存给程序。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>PHP7内存管理器的的代码是在php-7.x.x/Zend/zenc_alloc.c中实现的。它维护了三种规格的内存，分别是chunk、page、slot；</p>
<p>这三种大小是在php-7.x.x/Zend/zenc_alloc_sizes.h中定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define ZEND_MM_CHUNK_SIZE (2 * 1024 * 1024)               &#x2F;* 2 MB  *&#x2F;</span><br><span class="line">#define ZEND_MM_PAGE_SIZE  (4 * 1024)                      &#x2F;* 4 KB  *&#x2F;</span><br><span class="line">#define ZEND_MM_PAGES      (ZEND_MM_CHUNK_SIZE &#x2F; ZEND_MM_PAGE_SIZE)  &#x2F;* 512 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>page是在chunk中分配的，那么一个chunk可以分为2MB/4KB=512个page，如图2所示。</p>
<p><img src="http://ww1.sinaimg.cn/large/98f40ff8ly1gdiq5g0qh1j214g0a0q3w.jpg" alt="图2 chunk和page示意图"></p>
<p>在PHP 7中，对于chunk大块内存的申请是使用mmap函数实现的，其中mmap函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* MAP_FIXED leads to discarding of the old mapping, so it can&#39;t be used. *&#x2F;</span><br><span class="line">void *ptr &#x3D; mmap(addr, size, PROT_READ | PROT_WRITE, flags &#x2F;*| MAP_POPULATE | MAP_HUGETLB*&#x2F;, ZEND_MM_FD, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;PHP7中对应的调用如下</span><br><span class="line">ptr &#x3D; mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON | MAP_HUGETLB, -1, 0);</span><br></pre></td></tr></table></figure>

<p>各个参数的含义如下：</p>
<ol>
<li><strong>start</strong>：映射区开始地址，0表示由系统决定的起始地址，PHP7传入的NULL，也就是0</li>
<li><strong>length</strong>：映射区长度，以字节为单位，不足一页时按一页处理</li>
<li><strong>prot</strong>：期望的内存保护标志不能与文件的打开方式冲突。prot可以是以下的某个值，且可以使用or将合理的组合在一起：<ol>
<li>PROT_EXEC：页内容可执行</li>
<li>PROT_READ：页内容可读取</li>
<li>PROT_WRITE：页可以写入</li>
<li>PROT_NONE：页不可访问</li>
</ol>
</li>
</ol>
<p>PHP7中的为PROT_READ | PROT_WRITE，即可读写</p>
<ol start="4">
<li><strong>flags</strong>：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个位的组合体，PHP 7使用的是MAP_PRIVATE | MAP_ANON，前者是建立一个写入时复制的私有映射，后者表示匿名映射，映射区不与任何文件关联。</li>
<li><strong>fd</strong>：有效的文件描述词。PHP 7中设置为-1，此时需要指定flags参数中的MAP_ANON，表明进行的是匿名映射。</li>
<li><strong>off_toffset</strong>：被映射对象内容的起点，PHP 7中设置为0。</li>
</ol>
<p>PHP 7通过调用mmap函数，返回一大块内存，一般是chunk大小的倍数，后面的内存管理工作在这一大块内存上进行操作。</p>
<p>PHP 7的MM将申请内存按大小分成了3类：small内存、large内存、huge内存。</p>
<ol>
<li>small内存：小于等于3KB的内存。</li>
<li>large内存：大于3KB且小于等于（2MB-4KB）的内存，可以对应整数倍的page，之所以要减掉4KB一个page的大小，后面会详细展开。</li>
<li>huge内存：大于2MB-4KB的内存，可以直接对应整数倍的chunk。</li>
</ol>
<p>与mmap相反的操作是int munmap(void *start, size_t length)，用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小，该函数在释放内存的时候使用。</p>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>在用C/C++进行软件开发、申请内存时，编译器可以帮我们实现内存对齐，虽然看上去浪费了内存，但是提升了CPU访问内存的速度。</p>
<p>对齐举例：在PHP 7的内存池管理中，比如我们申请300B的内存，如果以256B对齐，则对齐后的内存应该是512B（256的2倍）。</p>
<p>PHP7中的内存对齐主要用到一下三个宏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;还是在zend_alloc.c中</span><br><span class="line">#define ZEND_MM_ALIGNED_OFFSET(size, alignment) \</span><br><span class="line">	(((size_t)(size)) &amp; ((alignment) - 1))</span><br><span class="line">#define ZEND_MM_ALIGNED_BASE(size, alignment) \</span><br><span class="line">	(((size_t)(size)) &amp; ~((alignment) - 1))</span><br><span class="line">#define ZEND_MM_SIZE_TO_NUM(size, alignment) \</span><br><span class="line">	(((size_t)(size) + ((alignment) - 1)) &#x2F; (alignment))</span><br></pre></td></tr></table></figure>

<p>如何理解这几个宏呢？下面举例来说明一下，假如要申请一个大小为4KB的内存，并以0x1000对齐，如图3所示。</p>
<p><img src="http://ww1.sinaimg.cn/large/98f40ff8ly1gdirezxr4hj20i60gg75l.jpg" alt="图3 内存地址对齐示例"></p>
<ul>
<li>申请0x1000+0x1000-0x0001=0x1fff的内存（也就是多申请0xfff的内存），比如申请到的起始地址为0x103c60120，结束地址为0x103c6211f；因为此时的地址不是0x1000对齐的（因为0x103c60120不是0x1000的整数倍），所以要进行对齐操作。</li>
<li>为了对齐，先释放0x103c60120到0x103c61000（恰好是起始地址和结束地址区间内0x1000的整数倍）的0xee0长度的内存，起始保证了起始地址为0x103c61000，是与0x1000对齐的。</li>
<li>释放0x103c62000到0x103c6211f的0x11f长度内存（两次释放的内存长度0xee0+0x11f=0xfff，恰好为多申请的长度）。</li>
<li>剩下的即为需要的0x1000长度，起始地址为0x103c61000，结束地址为0x103c62000的内存。</li>
</ul>
<p>使用此内存时，比如有一内存地址为0x103c61120，通过宏计算，可以得出，此内存所在的page的起始地址为0x103c61000，在此page的偏移量为0x120，能够快速定位内存地址所在的page，提高效率。</p>
<p>以上是内存管理的概念和内存对齐方法</p>
<hr>
<h1 id="内存管理的数据结构"><a href="#内存管理的数据结构" class="headerlink" title="内存管理的数据结构"></a>内存管理的数据结构</h1><p>PHP7的内存管理用到了一些结构体，其中核心的结构体有zend_mm_heap、zend_mm_page、zend_mm_chunk。其中zend_mm_page最简单，对应的是4KB的char数组，下面对zend_mm_heap和zenc_mm_chunk进行讨论。</p>
<h2 id="zend-mm-heap"><a href="#zend-mm-heap" class="headerlink" title="_zend_mm_heap"></a>_zend_mm_heap</h2><p>以下为_zend_mm_heap的结构体定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_mm_heap &#123;</span><br><span class="line">#if ZEND_MM_CUSTOM</span><br><span class="line">	int                use_custom_heap;</span><br><span class="line">#endif</span><br><span class="line">#if ZEND_MM_STORAGE</span><br><span class="line">	zend_mm_storage   *storage;</span><br><span class="line">#endif</span><br><span class="line">#if ZEND_MM_STAT</span><br><span class="line">	size_t             size;                    &#x2F;* current memory usage *&#x2F;</span><br><span class="line">	size_t             peak;                    &#x2F;* peak memory usage *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	zend_mm_free_slot *free_slot[ZEND_MM_BINS]; &#x2F;* free lists for small sizes *&#x2F;</span><br><span class="line">#if ZEND_MM_STAT || ZEND_MM_LIMIT</span><br><span class="line">	size_t             real_size;               &#x2F;* current size of allocated pages *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">#if ZEND_MM_STAT</span><br><span class="line">	size_t             real_peak;               &#x2F;* peak size of allocated pages *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">#if ZEND_MM_LIMIT</span><br><span class="line">	size_t             limit;                   &#x2F;* memory limit *&#x2F;</span><br><span class="line">	int                overflow;                &#x2F;* memory overflow flag *&#x2F;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	zend_mm_huge_list *huge_list;               &#x2F;* list of huge allocated blocks *&#x2F;</span><br><span class="line"></span><br><span class="line">	zend_mm_chunk     *main_chunk;</span><br><span class="line">	zend_mm_chunk     *cached_chunks;			&#x2F;* list of unused chunks *&#x2F;</span><br><span class="line">	int                chunks_count;			&#x2F;* number of allocated chunks *&#x2F;</span><br><span class="line">	int                peak_chunks_count;		&#x2F;* peak number of allocated chunks for current request *&#x2F;</span><br><span class="line">	int                cached_chunks_count;		&#x2F;* number of cached chunks *&#x2F;</span><br><span class="line">	double             avg_chunks_count;		&#x2F;* average number of chunks allocated per request *&#x2F;</span><br><span class="line">	int                last_chunks_delete_boundary; &#x2F;* numer of chunks after last deletion *&#x2F;</span><br><span class="line">	int                last_chunks_delete_count;    &#x2F;* number of deletion over the last boundary *&#x2F;</span><br><span class="line">#if ZEND_MM_CUSTOM</span><br><span class="line">	union &#123;</span><br><span class="line">		struct &#123;</span><br><span class="line">			void      *(*_malloc)(size_t);</span><br><span class="line">			void       (*_free)(void*);</span><br><span class="line">			void      *(*_realloc)(void*, size_t);</span><br><span class="line">		&#125; std;</span><br><span class="line">		struct &#123;</span><br><span class="line">			void      *(*_malloc)(size_t ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line">			void       (*_free)(void*  ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line">			void      *(*_realloc)(void*, size_t  ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line">		&#125; debug;</span><br><span class="line">	&#125; custom_heap;</span><br><span class="line">	HashTable *tracked_allocs;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面解释下变量的含义。</p>
<ol>
<li><p><strong>size/real_size</strong>：size代表的是MM当前申请的已使用的内存，real_size还包括申请的未使用的内存；可以通过PHP的函数memory_get_usage来获取，其PHP函数原型如下：</p>
<blockquote>
<p>int memory_get_usage([bool $real_usage = false])</p>
</blockquote>
<p> $real_usage默认为false，只返回使用的内存大小；对于true的情况，会返回包括没有使用的分配内存的大小。在PHP7的源码中有对应的实现：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API size_t zend_memory_usage(int real_usage)</span><br><span class="line">&#123;</span><br><span class="line">#if ZEND_MM_STAT</span><br><span class="line">    if (real_usage) &#123;</span><br><span class="line">        return AG(mm_heap)-&gt;real_size;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        size_t usage &#x3D; AG(mm_heap)-&gt;size;</span><br><span class="line">        return usage;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 从源码中可以看出参数为true时，返回的是real_size；当为false时，返回的是size；size和real_size会在申请和释放内存时进行修改。</p>
</li>
<li><p><strong>peak/real_peak</strong>：peak是emalloc上报的内存峰值，可以通过PHP的函数memory_get_peak_usage来获取，其PHP函数的原型如下：</p>
<blockquote>
<p>int memory_get_peak_usage([bool $real_usage = false])</p>
</blockquote>
<p>$real_usage默认为false，只返回emalloc上报的内存峰值大小；对于true的情况，会返回内存分配峰值的大小；在PHP7的源码中，有对应的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API size_t zend_memory_peak_usage(int real_usage)</span><br><span class="line"> &#123;</span><br><span class="line"> #if ZEND_MM_STAT</span><br><span class="line">     if (real_usage) &#123;</span><br><span class="line">         return AG(mm_heap)-&gt;real_peak;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         return AG(mm_heap)-&gt;peak;</span><br><span class="line">     &#125;</span><br><span class="line"> #endif</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>从源码中，可以看出true时返回的是real_peak，同样，在申请和释放内存时real_peak和peak也会进行修改。</p>
</li>
<li><p><strong>free_slot</strong>：指针数组，存储30种规格的small内存链表的首地址</p>
</li>
<li><p><strong>limit</strong>：存储在MM可申请内存的最大值，MM每当向系统申请chunk或huge的内存时，会判断申请后的内存值是否大于limit，如果大于，则进行垃圾回收。该参数可以通过php.ini中的memory_limit配置。</p>
</li>
<li><p><strong>overflow</strong>：当申请的内存总数超出MM的limit时，先进行垃圾回收，如果回收失败，则判断overflow是否为1，如果是1则抛出异常，中断进程（PHP项目中经常遇到的allowed memory size of ** byte exhausted tried to allocate ** bytes就是这样跑出来的)</p>
</li>
<li><p><strong>main_chunk</strong>：双向链表，存储使用中的chunk的首地址</p>
</li>
<li><p><strong>cached_chunks</strong>：双向链表，缓存的chunk的首地址</p>
</li>
<li><p><strong>chunks_count</strong>：使用中的chunk个数，也就是链表main_chunk中的元素个数。</p>
</li>
<li><p><strong>peak_chunks_count</strong>：此次http请求中申请的chunk个数最大值，初始化为1，且每次请求开始都会重置为1</p>
</li>
<li><p><strong>cached_chunks_count</strong>：缓存中的chunk个数，也就是链表cached_chunks中的元素个数</p>
</li>
<li><p><strong>avg_chunks_count</strong>：历次请求使用chunk的个数平均值，初始值为1.0，每次请求结束时，会重新计算此值，置为avg_chunks_count和peak_chunks_count的平均值。</p>
<p>对于chunk相关的变量，会在后续chunk章节详细展开</p>
</li>
<li><p><strong>huge_list</strong>：用以挂载分配的大块内存的单向列表，方便后续MM关闭时释放。</p>
</li>
</ol>
<p>结构体_zend_mm_heap本身是要占内存的，也保存在内存管理申请的内存中。</p>
<p>_zend_mm_heap中有一个非常重要的结构——_zend_mm_chunk，下面讨论一下这个结构体。</p>
<h2 id="zend-mm-chunk"><a href="#zend-mm-chunk" class="headerlink" title="_zend_mm_chunk"></a>_zend_mm_chunk</h2><p>PHP 7的MM是一个多级内存分配器——预先定义内存块级别，按需要分配空间的大小找到对应级别，对齐分配。前文提到，chunk大小为2MB；每个chunk可以切割为512个page，一个page是4KB。在chunk内部，以page为单位进行管理。参考以下宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define ZEND_MM_CHUNK_SIZE (2 * 1024 * 1024)               &#x2F;* 2 MB  *&#x2F;</span><br><span class="line">#define ZEND_MM_PAGE_SIZE  (4 * 1024)                      &#x2F;* 4 KB  *&#x2F;</span><br><span class="line">#define ZEND_MM_PAGES      (ZEND_MM_CHUNK_SIZE &#x2F; ZEND_MM_PAGE_SIZE)  &#x2F;* 512 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>一个chunk大小为2MB, MM管理chunk的变量，使用的是结构体_zend_mm_chunk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_mm_chunk &#123;</span><br><span class="line">	zend_mm_heap      *heap;</span><br><span class="line">	zend_mm_chunk     *next;</span><br><span class="line">	zend_mm_chunk     *prev;</span><br><span class="line">	uint32_t           free_pages;				&#x2F;* number of free pages *&#x2F;</span><br><span class="line">	uint32_t           free_tail;               &#x2F;* number of free pages at the end of chunk *&#x2F;</span><br><span class="line">	uint32_t           num;</span><br><span class="line">	char               reserve[64 - (sizeof(void*) * 3 + sizeof(uint32_t) * 3)];</span><br><span class="line">	zend_mm_heap       heap_slot;               &#x2F;* used only in main chunk *&#x2F;</span><br><span class="line">	zend_mm_page_map   free_map;                &#x2F;* 512 bits or 64 bytes *&#x2F;</span><br><span class="line">	zend_mm_page_info  map[ZEND_MM_PAGES];      &#x2F;* 2 KB &#x3D; 512 * 4 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>各变量的含义如下。</p>
<ol>
<li><strong>heap</strong>:zend_mm_heap类型的指针，对应的是9.3.1节中AG里面的mm_heap的地址。</li>
<li><strong>next</strong>:zend_mm_chunk类型的指针，指向下一个chunk。</li>
<li><strong>prev</strong>:zend_mm_chunk类型的指针，指向上一个chunk。由next/prev可见zend_mm_chunk是双向链表。</li>
<li><strong>free_pages</strong>：此chunk中可用的page个数，如图9-5所示，此chunk一共使用了9个page，则free_pages为512-9=503。</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/98f40ff8ly1gdj56xomjbj215408maau.jpg" alt="PHP7page使用情况分析"></p>
<ol start="5">
<li><strong>free_tail</strong>：此chunk的最后一块连续可用page的起始编号，主要用于快速查找连续可用page，此值并不准确，但不影响最后结果，如图9-5所示，free_tail应该为363。</li>
<li><strong>free_map</strong>：在64位机器下，其为8个元素的数组，每个元素为64bit的整型，所以一共有8×64bit=512bit，对应512个page。已使用的page，对应的bit置为1，灰色部分；未使用（可用）的page，对应的bit置为0，白色部分，如图所示。</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/98f40ff8ly1gdj58wrdqcj215g0omtef.jpg" alt="free_map对应的512bit"></p>
<ol start="7">
<li><p><strong>map</strong>:512个元素的数组，每个元素为一个32bit的整型，用来记录每个page的使用情况，比较复杂，如图所示。<br><img src="http://ww1.sinaimg.cn/large/98f40ff8ly1gdj5aq2lnzj215c086ab9.jpg" alt="PHP7内存管理large内存的map使用情况示例s"><br>高位的2个bit，用于标记此page的使用类型，有4种情况：0x0、0x1、0x2、0x3，其中0x0代表此page未使用，0x1代表此page用于large内存，0x2和0x3均代表此page用于small内存。当此page用于large内存时，如果低位的10个bit为0，则代表此page被其前面且连续的page一起用于一次申请的内存；如果非0，假定值为page_count，则代表此page开始的连续page_count个page一起用于一次申请的内存，比如图9-6中一次申请了3个连续的page，起始编号为360，那么map[360]、map[361]、map[362]的低10位分别为3、0、0。</p>
<blockquote>
<p>注意free_map是8× 8B，也就是8× 8× 8=512bit，这512个bit对应512个page，每个bit只能取0或者1，代表对应page的使用情况。而map是512个uint32_t，也就是512× 4B，每一个uint32_t代表一个page的使用情况。</p>
</blockquote>
</li>
<li><p><strong>num</strong>：代表此chunk在链表main_chunk中的编号，很明显，当申请第一个chunk时，num为0。对于非第一个chunk, num的值为在前一个chunk的num上加1。</p>
</li>
<li><p><strong>reserve</strong>：保留字段，在C语言开发中的结构体中尤为常见，用于结构体版本升级之类。10）heap_slot：在MM进行初始化时，会创建第一个chunk，而第一个chunk的此字段，才有意义。其实全局指针alloc_globals.mm_heap指向的便是第一个chunk的heap_slot。</p>
</li>
</ol>
<p>每申请一个chunk，都需要对chunk进行初始化，大致流程如下所示。</p>
<ol>
<li><p>将此chunk放入环状双向链表main_chunk的最后面。</p>
</li>
<li><p>将free_pages置为512-1=511（第0个page被chunk的头信息占用）。</p>
</li>
<li><p>将free_tail置为1。</p>
</li>
<li><p>将num在上一个元素的计数基础上加1（chunk-&gt;prev-&gt;num+1）。</p>
</li>
<li><p>将free_map[0]标记为1，代表第0个被使用。</p>
</li>
<li><p>将map[0]标记为0x40000000 | 0x01,0x40000000代表第0个page使用large内存，0x01代表从第0个page起，连续1个page被使用。</p>
<p>_zend_mm_chunk本身是要占用内存的，我们输出_zend_mm_chunk的size：</p>
<blockquote>
<p>(gdb) p sizeof(zend_mm_chunk) $3 = 2552</p>
</blockquote>
</li>
</ol>
<p>这个结构体占了2552B，它存放在chunk的第0个page上，如图所示。</p>
<p><img src="http://ww1.sinaimg.cn/large/98f40ff8ly1gdj5jv462gj212s0q60xa.jpg" alt="内存管理chunk和page在MM中的位置"></p>
<p>当申请一个chunk时，MM先判断双向链表cached_chunks是否存在chunk，如果不存在，则直接向操作系统申请一个地址以2MB对齐的chunk，添加到main_chunk中，然后返回给申请者；如果cached_chunks中存在chunk，则讲头部的chunk摘除，然后添加chunk进行初始化，一个chunk被分成512个page，其中511个page可用，第0个page用于存放这个chunk的管理结构体struct_zend_mm_chunk。</p>
<p>释放一个chunk时，MM先将此chunk从main_chunk中移除，并将chunks_count减一。然后判断当前使用的chunk数是否小于历次请求使用的chunk个数平均值avg_chunks_count。如果小于，则将此chunk放入双向链表cached_chunks中；如果不小于，则直接向操作系统释放此块内存。</p>
<p>到此我们研究了AG里面mm_heap的结构，以及chunk和page结构和相互关系，有了这些准备后，再来看下PHP内存管理的详细实现。</p>
<h1 id="内存管理的详细实现"><a href="#内存管理的详细实现" class="headerlink" title="内存管理的详细实现"></a>内存管理的详细实现</h1><hr>
<p>未完待续</p>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/PHP/">PHP</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"><span class="level-item">设计模式二-观察者模式</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: true,
            verify: true,
            appId: 'qulihbb8VNkutV2s1Bd66IgJ-gzGzoHsz',
            appKey: 'U0qM7U6zyUbcT5dwFQ9B4Y2L',
            placeholder: '欢迎评论',
            avatar: 'mm',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false
        });</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#内存管理准备知识"><span class="mr-2">1</span><span>内存管理准备知识</span></a><ul class="menu-list"><li><a class="is-flex" href="#基本概念"><span class="mr-2">1.1</span><span>基本概念</span></a></li><li><a class="is-flex" href="#内存对齐"><span class="mr-2">1.2</span><span>内存对齐</span></a></li></ul></li><li><a class="is-flex" href="#内存管理的数据结构"><span class="mr-2">2</span><span>内存管理的数据结构</span></a><ul class="menu-list"><li><a class="is-flex" href="#zend-mm-heap"><span class="mr-2">2.1</span><span>_zend_mm_heap</span></a></li><li><a class="is-flex" href="#zend-mm-chunk"><span class="mr-2">2.2</span><span>_zend_mm_chunk</span></a></li></ul></li><li><a class="is-flex" href="#内存管理的详细实现"><span class="mr-2">3</span><span>内存管理的详细实现</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="http://ww1.sinaimg.cn/large/98f40ff8ly1gdgywey9uvj203k03kglt.jpg" alt="杨航"></figure><p class="title is-size-4 is-block line-height-inherit">杨航</p><p class="is-size-6 is-block">Just do it!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/april2nd" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/april2nd"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/PHP/"><span class="level-start"><span class="level-item">PHP</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-05T02:01:07.000Z">2020-04-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/05/PHP7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">PHP7内存管理</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/PHP/">PHP</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-03T13:40:52.000Z">2020-04-03</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式二-观察者模式</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/PHP/">PHP</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-03T04:42:50.000Z">2020-04-03</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/03/Markdown%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/">Markdown模板文件</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/PHP/"><span class="tag">PHP</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B6%E4%BB%96/"><span class="tag">其他</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logos.svg" alt="杨航博客" height="28"></a><p class="size-small"><span>&copy; 2020 杨航</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://april2nd.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>