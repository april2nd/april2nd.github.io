{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"设计模式二-观察者模式","text":"单例模式是所有设计模式里第一个先讲的模式，相信所有人对单例已经有了解了，所以直接跳过了单例模式的讲解 本文章是结合了《深入PHP面向对象、模式与实践》和 Laravel学员君设计模式讲解 中的内容，说实话，对比起来学习效果真的很好。如果看不懂就抄写代码，抄完了可能就一知半解了，最后再搜索几个设计模式的场景看看就差不多了，反正我是这么搞过来的，效果还不错哈哈。 观察者模式问题我们直接从一个代码来看一下，这是一个负责处理用户登录以后的实例： 123456789101112131415161718192021222324252627class Login{ private $status = []; const LOGIN_USER_UNKNOWN = 1; const LOGIN_WRONG_PASS = 2; const LOGIN_ACCESS = 3; function handlerLogin($user, $pass, $ip){ $ret = true; if($ret){ $this-&gt;setStatus(self::LOGIN_ACCESS, $user, $ip); } return $ret; } function setStatus($status, $user, $ip){ $this-&gt;status = [$status, $user, $ip]; } function getStatus(){ return $this-&gt;status; }} 当我们在处理完用户登陆以后，一般会有一些其他的动作需要做，比如记录用户的登录日志，给用户发送一份验证邮箱等操作，这时候我们就需要扩展handlerLogin方法，如下 123456789101112131415function handlerLogin($user, $pass, $ip){ //业务处理验证登录 //此处省略 $ret = true; if($ret){ $this-&gt;setStatus(self::LOGIN_ACCESS, $user, $ip); } Logger::logIp($user, $ip, $this-&gt;getStatus()); return $ret;} 如果又有其他业务需求，等比较庞大，那handlerLogin就会比较冗长。其实这些需求都非常容易满足，但是会使代码变得很长。此时就有观察者模式来拯救这个Login类。 实现观察者模式的核心是把客户元素（观察者）从一个中心类（主体）中分离开来。当主体知道事件发生时，观察者需要被通知到。同时我们并不希望将主题和观察者时间的关系进行硬编码。为了达到这个目的，我们可以允许观察者在主体上进行注册。Login类有3个新方法—attach()\\detach()\\notify()如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//被观察者接口interface Observable{ function attach(Observer $observer); //PHP 7.2新特性：参数类型声明 function detach(Observer $observer); function notify();}class login implements Observable{ private $observers; //要存放的观察者们 private $status = []; const LOGIN_USER_UNKNOWN = 1; const LOGIN_WRONG_PASS = 2; const LOGIN_ACCESS = 3; function __constract(){ $this-&gt;observers = array(); } //注册观察者，将观察者对象塞入 function attach(Observer $observer){ $this-&gt;observers[] = $observer; } //从观察者集合中剔出观察者 function detach(Observer $observer){ $newobservers = array(); foreach($this-&gt;observers as $obs){ //把不等于当前的放到新的数组里，那新数组里就没有要剔出的观察者对象了 if($obs !== $observer){ $newobservers[] = $obs; } } $this-&gt;observers = $newobservers; } //通知被观察者 function notify(){ //当调用该方法的时候，会依次遍历观察者数组，然后执行观察者中的update方法，所以观察者中必须有该方法 foreach($this-&gt;observers as $obs){ $obs-&gt;update($this); } } //同时登陆完以后 执行$this-&gt;notify(); function handlerLogin($user, $pass, $ip){ //业务处理验证登录 //此处省略 $ret = true; if($ret){ $this-&gt;setStatus(self::LOGIN_ACCESS, $user, $ip); } $this-&gt;notify(); return $ret; } function setStatus($status, $user, $ip){ $this-&gt;status = [$status, $user, $ip]; } function getStatus(){ return $this-&gt;status; }} 现在Login类中新增的三个方法用来管理一些观察者。这些观察者可以由login类的attach添加进login类，也可以通过detach来移除。notify（）方法来告诉观察者一些相关事情发生了。notify（）方法会遍历观察者列表，调用每个观察者的update()方法。 定义一个观察者接口 1234interface Observer{ function update(Observable $observable);} 任何实现这个接口的对象都可以通过attach（）方法加入login类中，下面创建一个具体的实现的两个观察者： 123456789101112131415161718192021222324252627282930//登陆观察者发一封邮件给管理员class LoginMointor implements Observer{ function update(Observable $observable){ $status = $observable-&gt;getStatus(); if($status[0] == Login::LOGIN_ACCESS){ print __CLASS__.\":\\tsending mail to sysadmin\" } }}//记录日志观察者class LogMointor implements Observer{ function update(Observable $observable){ $status = $observable-&gt;getStatus(); if($status[0] == Login::LOGIN_ACCESS){ print __CLASS__.\":\\Log login info\" } }}$login = new Login();//注册登陆观察者$login-&gt;attach(new LoginMointor());//注册日志观察者$login-&gt;attach(new LogMointor());//执行登陆操作$login-&gt;handlerLogin(); 此时应该会打印出 LoginMointor: sending mail to sysadminLoginMointor: Log login info PHP内置SPL扩展PHP通过内置的SPL扩展提供了对观察者模式的原生支持，移步SplObserver 和 SplSubject 其中SplSubject相当于上面的 Observable 接口，SplObserver相当于上面的Observer观察者接口 者两个接口与我们自定义的没有什么区别，自定义只是可以重命名内置方法名，比如你不想叫notify这种，下面的代码，我们使用SPL实现一个类似的功能，比如买票，希望你可以读一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class buyTicket implements SplSubject{ private $observers = []; function __construct() { $this-&gt;observers = new SplObjectStorage(); } /** * 加入观察者 * @param SplObserver $observer */ public function attach(SplObserver $observer) { // TODO: Implement attach() method. $this-&gt;observers-&gt;attach($observer); } /** * 取消观察者 * @param SplObserver $observer */ public function detach(SplObserver $observer) { // TODO: Implement detach() method. $this-&gt;observers-&gt;detach($observer); } public function notify() { //做我自己的事情,比如登录 买票之类的 // 然后做观察者自己的事情 foreach($this-&gt;observers as $obs){ $obs-&gt;update($this); } }}class doOther implements SplObserver{ public function update(SplSubject $subject) { echo __CLASS__.\"\\n\"; }}$buy = new buyTicket();$buy-&gt;attach(new doOther());$buy-&gt;notify();","link":"/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"Markdown模板文件","text":"Markdown是一种轻量级的「标记语言」 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md” MdEditor是一个在线编辑Markdown文档的编辑器MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。 Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 MdEditor源于Pandao的JavaScript开源项目，开源地址Editor.md，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。 MdEditor的功能列表演示标题H1标题H2标题H3标题H4标题H5标题H5字符效果和横线等 删除线 删除线（开启识别HTML标签时） 斜体字 斜体字 粗体 粗体 粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 锚点与链接 Links普通链接普通链接带标题直接链接：https://www.mdeditor.com[锚点链接][anchor-id][anchor-id]: https://www.mdeditor.com/mailto:test.test@gmail.comGFM a-tail link @pandao邮箱地址自动链接 test.test@gmail.com www@vip.qq.com @pandao 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked 缩进风格即缩进四个空格，也做为实现类似 &lt;pre&gt; 预格式化文本 ( Preformatted Text ) 的功能。 &lt;?php echo &quot;Hello world!&quot;; ?&gt;预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell |JS代码123function test() { console.log(\"Hello world!\");} 123&lt;?php echo 'hello world';?&gt; HTML 代码 HTML codes1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=\"utf-8\" /&gt; &lt;meta name=\"keywords\" content=\"Editor.md, Markdown, Editor\" /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type=\"text/css\"&gt; body{font-size:14px;color:#444;font-family: \"Microsoft Yahei\", Tahoma, \"Hiragino Sans GB\", Arial;background:#fff;} ul{list-style: none;} img{border:none;vertical-align: middle;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=\"text-xxl\"&gt;Hello world!&lt;/h1&gt; &lt;p class=\"text-green\"&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 图片 Images图片加链接 (Image + Link)： Follow your heart. 列表 Lists无序列表（减号）Unordered Lists (-) 列表一 列表二 列表三 无序列表（星号）Unordered Lists (*) 列表一 列表二 列表三 无序列表（加号和嵌套）Unordered Lists (+) 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 Ordered Lists (-) 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 First Header Second Header Content Cell Content Cell Content Cell Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell Function name Description help() Display the help window. destroy() Destroy your computer! Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes&copy; &amp; &uml; &trade; &iexcl; &pound;&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo; 18&ordm;C &quot; &apos; [========] Emoji表情 :smiley: Blockquotes :star: GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x: :smiley: @mentions, :smiley: #refs, links, formatting, and tags supported :editormd-logo:; list syntax required (any unordered or ordered list supported) :editormd-logo-3x:; [ ] :smiley: this is a complete item :smiley:; []this is an incomplete item test link :fa-star: @pandao; [ ]this is an incomplete item :fa-star: :fa-gear:; :smiley: this is an incomplete item test link :fa-star: :fa-gear:; :smiley: this is :fa-star: :fa-gear: an incomplete item test link; 反斜杠 Escape*literal asterisks* [========] 科学公式 TeX(KaTeX)$$E=mc^2$$ 行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。 $$x &gt; y$$ $$(\\sqrt{3x-1}+(1+x)^2)$$ $$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$ 多行公式： $$math\\displaystyle\\left( \\sum_{k=1}^n a_k b_k \\right)^2\\leq\\left( \\sum_{k=1}^n a_k^2 \\right)\\left( \\sum_{k=1}^n b_k^2 \\right)$$ $$katex\\displaystyle \\frac{1}{ \\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{ \\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} { 1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$$$latexf(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi),e^{2 \\pi i \\xi x} ,d\\xi$$ 分页符 Page break Print Test: Ctrl + P [========] 绘制流程图 Flowchart12345678st=&gt;start: 用户登陆op=&gt;operation: 登陆操作cond=&gt;condition: 登陆成功 Yes or No?e=&gt;end: 进入后台st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op [========] 绘制序列图 Sequence Diagram1234Andrew-&gt;China: Says HelloNote right of China: China thinks\\nabout itChina--&gt;Andrew: How are you?Andrew-&gt;&gt;China: I am good thanks! End","link":"/2020/04/03/Markdown%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/"},{"title":"PHP7内存管理","text":"内存管理的意义：内存是系统中重要的基本资源之一，内存的管理是指其分配、使用和回收的管理；保障各个程序内存的正常分配和回收。 虽然操作系统以及提供了一套内存管理的函数，但是PHP还是自己实现了一套内存管理方案-PHP内存管理器（Zend Memory Manager简称MM）如下图： 从图中可以看出PHP脚本运行所需内存不是直接从系统调用的，而是先通过内存管理器提供的一系列API接口（zend-mm-alloc-small、alloc-large、alloc-huge等，alloc意思为分配，huge为超大）申请：如果MM中有足够的内存，则直接分配给脚本；如果MM中不够用，则MM再向系统申请。这样可以有效减少PHP向系统调用的次数，并且优化内存空间使用效率。因为C、C++需要手动申请和释放内存，所以其比PHP开发要难。 在此引入一个内存池的概念：提供了一个更有效率的解决方案，即预先规划一定数量的内存区块，使得整个程序可以在运行期规划（allocate）、使用（access）、归还（free）内存区块。一个池子无非就是先占用一块内存，然后给需要的人使用。 内存管理准备知识据PHP 7核心开发者描述，PHP 7在内存管理上的CPU时间节省达到了21%，提升巨大。 PH7其实是借鉴了前辈的内存管理方案：jemalloc和tcmalloc，这两个分别是火狐和chrome两大浏览器的内存管理器。这种内存管理器的内存分配思想大致就是：先申请一大块内存，自己先占着，然后再按照大中小三种规格分割成小块，放在内存池中。当程序申请内存时，MM从池子中挑选合适大小的内存给程序。 基本概念PHP7内存管理器的的代码是在php-7.x.x/Zend/zenc_alloc.c中实现的。它维护了三种规格的内存，分别是chunk、page、slot； 这三种大小是在php-7.x.x/Zend/zenc_alloc_sizes.h中定义的： 1234#define ZEND_MM_CHUNK_SIZE (2 * 1024 * 1024) /* 2 MB */#define ZEND_MM_PAGE_SIZE (4 * 1024) /* 4 KB */#define ZEND_MM_PAGES (ZEND_MM_CHUNK_SIZE / ZEND_MM_PAGE_SIZE) /* 512 */ page是在chunk中分配的，那么一个chunk可以分为2MB/4KB=512个page，如图2所示。 在PHP 7中，对于chunk大块内存的申请是使用mmap函数实现的，其中mmap函数原型如下： 123456/* MAP_FIXED leads to discarding of the old mapping, so it can't be used. */void *ptr = mmap(addr, size, PROT_READ | PROT_WRITE, flags /*| MAP_POPULATE | MAP_HUGETLB*/, ZEND_MM_FD, 0);//PHP7中对应的调用如下ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON | MAP_HUGETLB, -1, 0); 各个参数的含义如下： start：映射区开始地址，0表示由系统决定的起始地址，PHP7传入的NULL，也就是0 length：映射区长度，以字节为单位，不足一页时按一页处理 prot：期望的内存保护标志不能与文件的打开方式冲突。prot可以是以下的某个值，且可以使用or将合理的组合在一起： PROT_EXEC：页内容可执行 PROT_READ：页内容可读取 PROT_WRITE：页可以写入 PROT_NONE：页不可访问 PHP7中的为PROT_READ | PROT_WRITE，即可读写 flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个位的组合体，PHP 7使用的是MAP_PRIVATE | MAP_ANON，前者是建立一个写入时复制的私有映射，后者表示匿名映射，映射区不与任何文件关联。 fd：有效的文件描述词。PHP 7中设置为-1，此时需要指定flags参数中的MAP_ANON，表明进行的是匿名映射。 off_toffset：被映射对象内容的起点，PHP 7中设置为0。 PHP 7通过调用mmap函数，返回一大块内存，一般是chunk大小的倍数，后面的内存管理工作在这一大块内存上进行操作。 PHP 7的MM将申请内存按大小分成了3类：small内存、large内存、huge内存。 small内存：小于等于3KB的内存。 large内存：大于3KB且小于等于（2MB-4KB）的内存，可以对应整数倍的page，之所以要减掉4KB一个page的大小，后面会详细展开。 huge内存：大于2MB-4KB的内存，可以直接对应整数倍的chunk。 与mmap相反的操作是int munmap(void *start, size_t length)，用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小，该函数在释放内存的时候使用。 内存对齐在用C/C++进行软件开发、申请内存时，编译器可以帮我们实现内存对齐，虽然看上去浪费了内存，但是提升了CPU访问内存的速度。 对齐举例：在PHP 7的内存池管理中，比如我们申请300B的内存，如果以256B对齐，则对齐后的内存应该是512B（256的2倍）。 PHP7中的内存对齐主要用到一下三个宏 12345678//还是在zend_alloc.c中#define ZEND_MM_ALIGNED_OFFSET(size, alignment) \\ (((size_t)(size)) &amp; ((alignment) - 1))#define ZEND_MM_ALIGNED_BASE(size, alignment) \\ (((size_t)(size)) &amp; ~((alignment) - 1))#define ZEND_MM_SIZE_TO_NUM(size, alignment) \\ (((size_t)(size) + ((alignment) - 1)) / (alignment)) 如何理解这几个宏呢？下面举例来说明一下，假如要申请一个大小为4KB的内存，并以0x1000对齐，如图3所示。 申请0x1000+0x1000-0x0001=0x1fff的内存（也就是多申请0xfff的内存），比如申请到的起始地址为0x103c60120，结束地址为0x103c6211f；因为此时的地址不是0x1000对齐的（因为0x103c60120不是0x1000的整数倍），所以要进行对齐操作。 为了对齐，先释放0x103c60120到0x103c61000（恰好是起始地址和结束地址区间内0x1000的整数倍）的0xee0长度的内存，起始保证了起始地址为0x103c61000，是与0x1000对齐的。 释放0x103c62000到0x103c6211f的0x11f长度内存（两次释放的内存长度0xee0+0x11f=0xfff，恰好为多申请的长度）。 剩下的即为需要的0x1000长度，起始地址为0x103c61000，结束地址为0x103c62000的内存。 使用此内存时，比如有一内存地址为0x103c61120，通过宏计算，可以得出，此内存所在的page的起始地址为0x103c61000，在此page的偏移量为0x120，能够快速定位内存地址所在的page，提高效率。 以上是内存管理的概念和内存对齐方法 内存管理的数据结构PHP7的内存管理用到了一些结构体，其中核心的结构体有zend_mm_heap、zend_mm_page、zend_mm_chunk。其中zend_mm_page最简单，对应的是4KB的char数组，下面对zend_mm_heap和zenc_mm_chunk进行讨论。 _zend_mm_heap以下为_zend_mm_heap的结构体定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct _zend_mm_heap {#if ZEND_MM_CUSTOM int use_custom_heap;#endif#if ZEND_MM_STORAGE zend_mm_storage *storage;#endif#if ZEND_MM_STAT size_t size; /* current memory usage */ size_t peak; /* peak memory usage */#endif zend_mm_free_slot *free_slot[ZEND_MM_BINS]; /* free lists for small sizes */#if ZEND_MM_STAT || ZEND_MM_LIMIT size_t real_size; /* current size of allocated pages */#endif#if ZEND_MM_STAT size_t real_peak; /* peak size of allocated pages */#endif#if ZEND_MM_LIMIT size_t limit; /* memory limit */ int overflow; /* memory overflow flag */#endif zend_mm_huge_list *huge_list; /* list of huge allocated blocks */ zend_mm_chunk *main_chunk; zend_mm_chunk *cached_chunks; /* list of unused chunks */ int chunks_count; /* number of allocated chunks */ int peak_chunks_count; /* peak number of allocated chunks for current request */ int cached_chunks_count; /* number of cached chunks */ double avg_chunks_count; /* average number of chunks allocated per request */ int last_chunks_delete_boundary; /* numer of chunks after last deletion */ int last_chunks_delete_count; /* number of deletion over the last boundary */#if ZEND_MM_CUSTOM union { struct { void *(*_malloc)(size_t); void (*_free)(void*); void *(*_realloc)(void*, size_t); } std; struct { void *(*_malloc)(size_t ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC); void (*_free)(void* ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC); void *(*_realloc)(void*, size_t ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC); } debug; } custom_heap; HashTable *tracked_allocs;#endif}; 下面解释下变量的含义。 size/real_size：size代表的是MM当前申请的已使用的内存，real_size还包括申请的未使用的内存；可以通过PHP的函数memory_get_usage来获取，其PHP函数原型如下： int memory_get_usage([bool $real_usage = false]) $real_usage默认为false，只返回使用的内存大小；对于true的情况，会返回包括没有使用的分配内存的大小。在PHP7的源码中有对应的实现： 12345678910111213ZEND_API size_t zend_memory_usage(int real_usage){#if ZEND_MM_STAT if (real_usage) { return AG(mm_heap)-&gt;real_size; } else { size_t usage = AG(mm_heap)-&gt;size; return usage; }#endif return 0;} 从源码中可以看出参数为true时，返回的是real_size；当为false时，返回的是size；size和real_size会在申请和释放内存时进行修改。 peak/real_peak：peak是emalloc上报的内存峰值，可以通过PHP的函数memory_get_peak_usage来获取，其PHP函数的原型如下： int memory_get_peak_usage([bool $real_usage = false]) $real_usage默认为false，只返回emalloc上报的内存峰值大小；对于true的情况，会返回内存分配峰值的大小；在PHP7的源码中，有对应的实现： 123456789101112ZEND_API size_t zend_memory_peak_usage(int real_usage) { #if ZEND_MM_STAT if (real_usage) { return AG(mm_heap)-&gt;real_peak; } else { return AG(mm_heap)-&gt;peak; } #endif return 0; } 从源码中，可以看出true时返回的是real_peak，同样，在申请和释放内存时real_peak和peak也会进行修改。 free_slot：指针数组，存储30种规格的small内存链表的首地址 limit：存储在MM可申请内存的最大值，MM每当向系统申请chunk或huge的内存时，会判断申请后的内存值是否大于limit，如果大于，则进行垃圾回收。该参数可以通过php.ini中的memory_limit配置。 overflow：当申请的内存总数超出MM的limit时，先进行垃圾回收，如果回收失败，则判断overflow是否为1，如果是1则抛出异常，中断进程（PHP项目中经常遇到的allowed memory size of ** byte exhausted tried to allocate ** bytes就是这样跑出来的) main_chunk：双向链表，存储使用中的chunk的首地址 cached_chunks：双向链表，缓存的chunk的首地址 chunks_count：使用中的chunk个数，也就是链表main_chunk中的元素个数。 peak_chunks_count：此次http请求中申请的chunk个数最大值，初始化为1，且每次请求开始都会重置为1 cached_chunks_count：缓存中的chunk个数，也就是链表cached_chunks中的元素个数 avg_chunks_count：历次请求使用chunk的个数平均值，初始值为1.0，每次请求结束时，会重新计算此值，置为avg_chunks_count和peak_chunks_count的平均值。 对于chunk相关的变量，会在后续chunk章节详细展开 huge_list：用以挂载分配的大块内存的单向列表，方便后续MM关闭时释放。 结构体_zend_mm_heap本身是要占内存的，也保存在内存管理申请的内存中。 _zend_mm_heap中有一个非常重要的结构——_zend_mm_chunk，下面讨论一下这个结构体。 _zend_mm_chunkPHP 7的MM是一个多级内存分配器——预先定义内存块级别，按需要分配空间的大小找到对应级别，对齐分配。前文提到，chunk大小为2MB；每个chunk可以切割为512个page，一个page是4KB。在chunk内部，以page为单位进行管理。参考以下宏： 1234#define ZEND_MM_CHUNK_SIZE (2 * 1024 * 1024) /* 2 MB */#define ZEND_MM_PAGE_SIZE (4 * 1024) /* 4 KB */#define ZEND_MM_PAGES (ZEND_MM_CHUNK_SIZE / ZEND_MM_PAGE_SIZE) /* 512 */ 一个chunk大小为2MB, MM管理chunk的变量，使用的是结构体_zend_mm_chunk： 12345678910111213struct _zend_mm_chunk { zend_mm_heap *heap; zend_mm_chunk *next; zend_mm_chunk *prev; uint32_t free_pages; /* number of free pages */ uint32_t free_tail; /* number of free pages at the end of chunk */ uint32_t num; char reserve[64 - (sizeof(void*) * 3 + sizeof(uint32_t) * 3)]; zend_mm_heap heap_slot; /* used only in main chunk */ zend_mm_page_map free_map; /* 512 bits or 64 bytes */ zend_mm_page_info map[ZEND_MM_PAGES]; /* 2 KB = 512 * 4 */}; 各变量的含义如下。 heap:zend_mm_heap类型的指针，对应的是9.3.1节中AG里面的mm_heap的地址。 next:zend_mm_chunk类型的指针，指向下一个chunk。 prev:zend_mm_chunk类型的指针，指向上一个chunk。由next/prev可见zend_mm_chunk是双向链表。 free_pages：此chunk中可用的page个数，如图9-5所示，此chunk一共使用了9个page，则free_pages为512-9=503。 free_tail：此chunk的最后一块连续可用page的起始编号，主要用于快速查找连续可用page，此值并不准确，但不影响最后结果，如图9-5所示，free_tail应该为363。 free_map：在64位机器下，其为8个元素的数组，每个元素为64bit的整型，所以一共有8×64bit=512bit，对应512个page。已使用的page，对应的bit置为1，灰色部分；未使用（可用）的page，对应的bit置为0，白色部分，如图所示。 map:512个元素的数组，每个元素为一个32bit的整型，用来记录每个page的使用情况，比较复杂，如图所示。高位的2个bit，用于标记此page的使用类型，有4种情况：0x0、0x1、0x2、0x3，其中0x0代表此page未使用，0x1代表此page用于large内存，0x2和0x3均代表此page用于small内存。当此page用于large内存时，如果低位的10个bit为0，则代表此page被其前面且连续的page一起用于一次申请的内存；如果非0，假定值为page_count，则代表此page开始的连续page_count个page一起用于一次申请的内存，比如图9-6中一次申请了3个连续的page，起始编号为360，那么map[360]、map[361]、map[362]的低10位分别为3、0、0。 注意free_map是8× 8B，也就是8× 8× 8=512bit，这512个bit对应512个page，每个bit只能取0或者1，代表对应page的使用情况。而map是512个uint32_t，也就是512× 4B，每一个uint32_t代表一个page的使用情况。 num：代表此chunk在链表main_chunk中的编号，很明显，当申请第一个chunk时，num为0。对于非第一个chunk, num的值为在前一个chunk的num上加1。 reserve：保留字段，在C语言开发中的结构体中尤为常见，用于结构体版本升级之类。10）heap_slot：在MM进行初始化时，会创建第一个chunk，而第一个chunk的此字段，才有意义。其实全局指针alloc_globals.mm_heap指向的便是第一个chunk的heap_slot。 每申请一个chunk，都需要对chunk进行初始化，大致流程如下所示。 将此chunk放入环状双向链表main_chunk的最后面。 将free_pages置为512-1=511（第0个page被chunk的头信息占用）。 将free_tail置为1。 将num在上一个元素的计数基础上加1（chunk-&gt;prev-&gt;num+1）。 将free_map[0]标记为1，代表第0个被使用。 将map[0]标记为0x40000000 | 0x01,0x40000000代表第0个page使用large内存，0x01代表从第0个page起，连续1个page被使用。 _zend_mm_chunk本身是要占用内存的，我们输出_zend_mm_chunk的size： (gdb) p sizeof(zend_mm_chunk) $3 = 2552 这个结构体占了2552B，它存放在chunk的第0个page上，如图所示。 当申请一个chunk时，MM先判断双向链表cached_chunks是否存在chunk，如果不存在，则直接向操作系统申请一个地址以2MB对齐的chunk，添加到main_chunk中，然后返回给申请者；如果cached_chunks中存在chunk，则讲头部的chunk摘除，然后添加chunk进行初始化，一个chunk被分成512个page，其中511个page可用，第0个page用于存放这个chunk的管理结构体struct_zend_mm_chunk。 释放一个chunk时，MM先将此chunk从main_chunk中移除，并将chunks_count减一。然后判断当前使用的chunk数是否小于历次请求使用的chunk个数平均值avg_chunks_count。如果小于，则将此chunk放入双向链表cached_chunks中；如果不小于，则直接向操作系统释放此块内存。 到此我们研究了AG里面mm_heap的结构，以及chunk和page结构和相互关系，有了这些准备后，再来看下PHP内存管理的详细实现。 PHP内存管理器初始化流程 内存分配的函数调用流程可在php7.x.x/Zend/zend_alloc.c中搜索_emalloc追溯相关代码 内存释放的函数调用流程123456789101112131415161718192021222324252627282930313233343536373839404142434445ZEND_API void ZEND_FASTCALL _efree(void *ptr){ zend_mm_free_heap(AG(mm_heap), ptr);} static zend_always_inline void zend_mm_free_heap(zend_mm_heap *heap, void *ptr){ //计算当前地址ptr相对于chunk的偏移 size_t page_offset = ZEND_MM_ALIGNED_OFFSET(ptr, ZEND_MM_CHUNK_SIZE); //偏移为0，说明是huge内存，直接释放 if (UNEXPECTED(page_offset == 0)) { if (ptr != NULL) { zend_mm_free_huge(heap, ptr); } } else { //计算chunk首地址 zend_mm_chunk *chunk = (zend_mm_chunk*)ZEND_MM_ALIGNED_BASE(ptr, ZEND_MM_CHUNK_SIZE); //计算页号 int page_num = (int)(page_offset / ZEND_MM_PAGE_SIZE); //获得页属性信息 zend_mm_page_info info = chunk-&gt;map[page_num]; //small内存 if (EXPECTED(info &amp; ZEND_MM_IS_SRUN)) { zend_mm_free_small(heap, ptr, ZEND_MM_SRUN_BIN_NUM(info)); } //large内存 else /* if (info &amp; ZEND_MM_IS_LRUN) */ { int pages_count = ZEND_MM_LRUN_PAGES(info); //将页标记为空闲 zend_mm_free_large(heap, chunk, page_num, pages_count); } }}static zend_always_inline void zend_mm_free_small(zend_mm_heap *heap, void *ptr, int bin_num){ zend_mm_free_slot *p; //插入空闲链表头部即可 p = (zend_mm_free_slot*)ptr; p-&gt;next_free_slot = heap-&gt;free_slot[bin_num]; heap-&gt;free_slot[bin_num] = p;} PHP内存管理总结1）需要明白一点：任何内存分配器都需要额外的数据结构来记录内存的分配情况； 2）内存池是代替直接调用malloc/free、new/delete进行内存管理的常用方法；内存池中空闲内存块组织为链表结果，申请内存只需要查找空闲链表即可，释放内存需要将内存块重新插入空闲链表； 3）PHP采用预分配内存策略，提前向操作系统分配2M字节大小内存，称为chunk；同时将内存分配请求根据字节大小分为small、huge、large三种； 4）small内存，采用“分离存储”思想；将空闲内存块按照字节大小组织为多个空闲链表； 5）large内存每次回分配连续若干个页，采用最佳适配算法； 6）huge内存直接使用mmap函数向操作系统申请内存（申请大小是2M字节整数倍）； 7）chunk中的每个页只会被切割为相同规格的内存块；所以不需要再每个内存块添加头部，只需要记录每个页的属性即可； 8）如何方便根据地址计算当前内存块属于chunk中的哪一个页？PHP分配的chunk都是2M字节对齐的，任意地址的低21位即是相对chunk首地址，除以页大小则可获得页号； 未完待续","link":"/2020/04/05/PHP7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"Mac相关小技巧","text":"Mac设置比较友好的且带颜色的命令行提示符PS1 如下： PS1=’[\\e]2;\\u@\\h:\\w\\a][\\e[36;1m]\\u@doit:[\\e[32;1m]\\w[\\e[36;1m]&gt; [\\e[0m] ‘ Mac vscode 请更新includePath错误修复：执行以下命令 $gcc -v -E -x c++ - 找到如下内容 #include “…” search starts here:#include &lt;…&gt; search starts here: /usr/local/include /Library/Developer/CommandLineTools/usr/bin/../include/c++/v1 /Library/Developer/CommandLineTools/usr/lib/clang/11.0.0/include /Library/Developer/CommandLineTools/usr/include /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks (framework directory)End of search list. 将以下一行内容 copy到工作区相应项目目录下的.vscode中的c_cpp_properties.json中 /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include 效果如下图 hexo发布后重新配置Custom domainhexo每次发布后都要重新配置Custom domain，即自定义域名失效，出现github404页面，在hexo的blog所在目录下有个source目录，在里面创建一个CNAME文件，然后在里面添加上自己的域名即可： 12touch source/CNAME &amp;&amp; echo april2nd.top &gt; source/CNAME","link":"/2020/04/05/Mac%E7%9B%B8%E5%85%B3%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"title":"设计模式三-工厂模式","text":"概念工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。 使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。 根据抽象程度的不同，PHP工厂模式分为三种： 简单工厂模式 工厂方法模式 抽象工厂模式 讲解简单工厂模式简单工厂模式又称静态工厂方法模式，之所以可以这么说，是因为简单工厂模式是通过一个静态方法来创建对象的。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?php/** *简单工厂模式（静态工厂方法模式） *//** * Interface people 人类 */interface people{ public function say();}/** * Class man 继承people的男人类 */class man implements people{ // 具体实现people的say方法 public function say() { echo '我是男人&lt;br&gt;'; }}/** * Class women 继承people的女人类 */class women implements people{ // 具体实现people的say方法 public function say() { echo '我是女人&lt;br&gt;'; }}/** * Class SimpleFactoty 工厂类 */class SimpleFactoty{ // 简单工厂里的静态方法-用于创建男人对象 static function createMan() { return new man(); } // 简单工厂里的静态方法-用于创建女人对象 static function createWomen() { return new women(); }}/** * 具体调用 */$man = SimpleFactoty::createMan();$man-&gt;say();$woman = SimpleFactoty::createWomen();$woman-&gt;say(); 运行结果： 我是男人 我是女人 工厂方法模式定义一个用于创建对象的接口，让子类决定哪个类实例化。 他可以解决简单工厂模式中的封闭开放原则问题。 看代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495header('Content-type:text/html;charset=utf-8');/* *工厂方法模式 *//** * Interface people 人类 */interface people{ public function say();}/** * Class man 继承people的男人类 */class man implements people{ // 实现people的say方法 function say() { echo '我是男人-hi&lt;br&gt;'; }}/** * Class women 继承people的女人类 */class women implements people{ // 实现people的say方法 function say() { echo '我是女人-hi&lt;br&gt;'; }}/** * Interface createPeople 创建人物类 * 注意：与上面简单工厂模式对比。这里本质区别在于 * 此处是将对象的创建抽象成一个接口。 */interface createPeople{ public function create();}/** * Class FactoryMan 继承createPeople的工厂类 * -用于实例化男人类 */class FactoryMan implements createPeople{ // 创建男人对象（实例化男人类） public function create() { return new man(); }}/** * Class FactoryMan 继承createPeople的工厂类 * -用于实例化女人类 */class FactoryWomen implements createPeople{ // 创建女人对象（实例化女人类） function create() { return new women(); }}/** * Class Client 操作具体类 */class Client{ // 具体生产对象并执行对象方法测试 public function test() { $factory = new FactoryMan(); $man = $factory-&gt;create(); $man-&gt;say(); $factory = new FactoryWomen(); $man = $factory-&gt;create(); $man-&gt;say(); }}// 执行$demo = new Client;$demo-&gt;test(); 看结果： 我是男人-hi 我是女人-hi 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口。 注意：这里和工厂方法的区别是：一系列（多个），而工厂方法只有一个。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;?phpheader('Content-type:text/html;charset=utf-8');/* * 抽象工厂模式 *//** * Interface people 人类 */interface people{ public function say();}/** * Class OneMan 第一个男人类-继承people */class OneMan implements people{ // 实现people的say方法 public function say() { echo '男1：我喜欢你&lt;br&gt;'; }}/** * Class TwoMan 第二个男人类-继承people */class TwoMan implements people{ // 实现people的say方法 public function say() { echo '男2：我看上你了&lt;br&gt;'; }}/** * Class OneWomen 第一个女人类-继承people */class OneWomen implements people { // 实现people的say方法 public function say() { echo '女1：我不喜欢你&lt;br&gt;'; }}/** * Class TwoWomen 第二个女人类-继承people */class TwoWomen implements people { // 实现people的say方法 public function say() { echo '女2：滚一边玩去&lt;br&gt;'; }}/** * Interface createPeople 创建对象类 * 注意:这里将对象的创建抽象成了一个接口。 */interface createPeople{ // 创建第一个 public function createOne(); // 创建第二个 public function createTwo();}/** * Class FactoryMan 用于创建男人对象的工厂类- * 继承createPeople */class FactoryMan implements createPeople{ // 创建第一个男人 public function createOne() { return new OneMan(); } // 创建第二个男人 public function createTwo() { return new TwoMan(); }}/** * Class FactoryWomen 用于创建女人对象的工厂类- * 继承createPeople */class FactoryWomen implements createPeople{ // 创建第一个女人 public function createOne() { return new OneWomen(); } // 创建第二个女人 public function createTwo() { return new TwoWomen(); }}/** * Class Client 执行测试类 */class Client { // 具体生成对象和执行方法 public function test() { // 男人 $factory = new FactoryMan(); $man = $factory-&gt;createOne(); $man-&gt;say(); $man = $factory-&gt;createTwo(); $man-&gt;say(); // 女人 $factory = new FactoryWomen(); $man = $factory-&gt;createOne(); $man-&gt;say(); $man = $factory-&gt;createTwo(); $man-&gt;say(); }}// 执行$demo = new Client;$demo-&gt;test(); 结果： 男1：我喜欢你 男2：我看上你了 女1：我不喜欢你 女2：滚一边玩去 总结区别 简单工厂模式(静态方法工厂模式) ： 用来生产同一等级结构中的任意产品。（不能增加新的产品） 工厂模式 ：用来生产同一等级结构中的固定产品。（支持增加任意产品） 抽象工厂 ：用来生产不同产品种类的全部产品。（不能增加新的产品，支持增加产品种类） 适用范围简单工厂模式工厂类负责创建的对象较少，操作时只需知道传入工厂类的参数即可，对于如何创建对象过程不用关心。 工厂方法模式 当一个类不知道它所必须创建对象的类时 一个类希望由子类来指定它所创建的对象时 当类将创建对象的职责委托给多个帮助子类中得某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时 抽象工厂模式满足以下条件时，可以考虑使用抽象工厂模式： 系统不依赖于产品类实例如何被创建，组合和表达的细节。 系统的产品有多于一个的产品族，而系统只消费其中某一族的产品 同属于同一个产品族是在一起使用的。这一约束必须在系统的设计中体现出来。 系统提供一个产品类的库，所有产品以同样的接口出现，从而使客户端不依赖于实现。 以上几种，归根结底，都是将重复的东西提取出来，以方便整体解耦和复用，修改时方便。可根据具体需求而选择使用。","link":"/2020/04/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"PHP奇淫技巧(长期更新)","text":"可变参数的函数1234567891011121314151617181920//第一种##$param = ['a','b','c'];function test($a,$b,$c){ var_dump($a,$b,$c);}echo \"old style:\\n\";//旧方式test($param[0],$param[1],$param[2]);echo \"new style:\\n\";//可变参数test(...$param);//第二种##function test(...$params){ return array_sum($params);}echo test(1,2,3,4,5); 链式访问123456789101112131415161718class test{ function __construct(){ } function a(){ echo 'a\\n'; return $this; } function b(){ echo 'b\\n'; return $this; }}$str = new test();$str-&gt;a()-&gt;b();","link":"/2020/04/08/PHP%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"title":"PHP7生命周期","text":"SAPI运行PHP都经过下面几个阶段: 模块初始化阶段（module init）：这个阶段主要进行php框架、zend引擎的初始化操作。这个阶段一般是在SAPI启动时执行一次，对于FPM而言，就是在fpm的master进行启动时执行的。php加载每个扩展的代码并调用其模块初始化例程（MINIT），进行一些模块所需变量的申请,内存分配等。 请求初始化阶段（request init）：当一个页面请求发生时，在请求处理前都会经历的一个阶段。对于fpm而言，是在worker进程accept一个请求并读取、解析完请求数据后的一个阶段。在这个阶段内，SAPI层将控制权交给PHP层，PHP初始化本次请求执行脚本所需的环境变量。 php脚本执行阶段php代码解析执行的过程。Zend引擎接管控制权，将php脚本代码编译成opcodes并顺次执行 请求结束阶段（request shutdown）：请求处理完后就进入了结束阶段，PHP就会启动清理程序。这个阶段，将flush输出内容、发送http响应内容等，然后它会按顺序调用各个模块的RSHUTDOWN方法。 RSHUTDOWN用以清除程序运行时产生的符号表，也就是对每个变量调用unset函数。 模块关闭阶段（module shutdown）：该阶段在SAPI关闭时执行，与模块初始化阶段对应，这个阶段主要是进行资源的清理、php各模块的关闭操作，同时，将回调各扩展的module shutdown钩子函数。这是发生在所有请求都已经结束之后，例如关闭fpm的操作。（这个是对于CGI和CLI等SAPI，没有“下一个请求”，所以SAPI立刻开始关闭。）","link":"/2020/04/07/PHP7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"Redis主从同步","text":"主从复制概述主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。 主从复制的作用主从复制的作用主要包括： 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。 主从复制的实现原理上面一节中，介绍了如何操作可以建立主从关系；本小节将介绍主从复制的实现原理。 主从复制过程大体可以分为3个阶段：连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段；下面分别进行介绍。 连接建立阶段该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。 步骤1：保存主节点信息 从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。 需要注意的是，slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。步骤2：建立socket连接 从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。 从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。 主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。步骤3：发送ping命令 从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。 从节点发送ping命令后，可能出现3种情况： （1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。 （2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。 （3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。步骤4：身份验证 如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。 如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。步骤5：发送从节点端口信息 身份验证之后，从节点会向主节点发送其监听的端口号（前述例子中为6380），主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。数据同步阶段主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步。 数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制，下面会有一章专门讲解这两种复制方式以及psync命令的执行过程，这里不再详述。 需要注意的是，在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。 命令传播阶段数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。 在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。由于心跳机制的原理涉及部分复制，因此将在介绍了部分复制的相关内容后单独介绍该心跳机制。 延迟与不一致需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。 repl-disable-tcp-nodelay no：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。 一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。 全量复制Redis通过psync命令进行全量复制的过程如下： 从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制；具体判断过程需要在讲述了部分复制原理后再介绍。 主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令 主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态 主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态 如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态 其中，有几点需要注意：从节点接收了来自主节点的89260个字节的数据；从节点在载入主节点的数据之前要先将老数据清除；从节点在同步完数据后，调用了bgrewriteaof。 通过全量复制的过程可以看出，全量复制是非常重型的操作： 主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的； 主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗 从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗 部分复制由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。 部分复制的实现，依赖于三个重要的概念： 复制偏移量主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。 offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。 复制积压缓冲区复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。 在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。 由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。 从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制： 如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。 服务器运行ID(runid)每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid： 主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制： 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)； 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。 psync命令的执行在了解了复制偏移量、复制积压缓冲区、节点运行id之后，本节将介绍psync命令的参数和返回值，从而说明psync命令执行过程中，主从节点是如何确定使用全量复制还是部分复制的。 首先，从节点根据当前状态，决定如何调用psync命令： 如果从节点之前未执行过slaveof或最近执行了slaveof no one，则从节点发送命令为psync ? -1，向主节点请求全量复制； 如果从节点之前执行了slaveof，则发送命令为psync ，其中runid为上次复制的主节点的runid，offset为上次复制截止时从节点保存的复制偏移量。 主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制： 如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制； 如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可； 如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复+FULLRESYNC ，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。 【命令传播阶段】心跳机制在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。 主-&gt;从：PING每隔指定的时间，主节点会向从节点发送PING命令，这个PING命令的作用，主要是为了让从节点进行超时判断。 PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。 关于该PING命令究竟是由主节点发给从节点，还是相反，有一些争议；因为在Redis的官方文档中，对该参数的注释中说明是从节点向主节点发送PING命令 但是根据该参数的名称(含有ping-slave)，以及代码实现，我认为该PING命令是主节点发给从节点的。 从-&gt;主：REPLCONF ACK在命令传播阶段，从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量。REPLCONF ACK命令的作用包括： 实时监测主从节点网络状态：该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1 检测命令丢失：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。注意，offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。 辅助保证从节点的数量和延迟：Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。 应用中的问题读写分离及其中的问题在主从复制基础上实现的读写分离，可以实现Redis的读负载均衡：由主节点提供写服务，由一个或多个从节点提供读服务（多个从节点既可以提高数据冗余程度，也可以最大化读负载能力）；在读负载较大的应用场景下，可以大大提高Redis服务器的并发量。下面介绍在使用Redis读写分离时，需要注意的问题。 延迟与不一致问题 前面已经讲到，由于主从复制的命令传播是异步的，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；使用集群同时扩展写负载和读负载等。 在命令传播阶段以外的其他情况下，从节点的数据不一致可能更加严重，例如连接在数据同步阶段，或从节点失去与主节点的连接时等。从节点的slave-serve-stale-data参数便与此有关：它控制这种情况下从节点的表现；如果为yes（默认值），则从节点仍能够响应客户端的命令，如果为no，则从节点只能响应info、slaveof等少数命令。该参数的设置与应用对数据一致性的要求有关；如果对数据一致性要求很高，则应设置为no。 数据过期问题 在单机版Redis中，存在两种删除策略： 惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。 定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。 在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。 Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。 故障切换问题 在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的Redis节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。 总结 在使用读写分离之前，可以考虑其他方法增加Redis的读负载能力：如尽量优化主节点（减少慢查询、减少持久化等其他情况带来的阻塞等）提高负载能力；使用Redis集群同时提高读负载能力和写负载能力等。如果使用读写分离，可以使用哨兵，使主从节点的故障切换尽可能自动化，并减少对应用程序的侵入。 复制超时问题主从节点复制超时是导致复制中断的最重要的原因之一，本小节单独说明超时问题，下一小节说明其他会导致复制中断的问题。 超时判断意义 在复制连接建立过程中及之后，主从节点都有机制判断连接是否超时，其意义在于： 如果主节点判断连接超时，其会释放相应从节点的连接，从而释放各种资源，否则无效的从节点仍会占用主节点的各种资源（输出缓冲区、带宽、连接等）；此外连接超时的判断可以让主节点更准确的知道当前有效从节点的个数，有助于保证数据安全（配合前面讲到的min-slaves-to-write等参数）。 如果从节点判断连接超时，则可以及时重新建立连接，避免与主节点数据长期的不一致。 判断机制 主从复制超时判断的核心，在于repl-timeout参数，该参数规定了超时时间的阈值（默认60s），对于主节点和从节点同时有效；主从节点触发超时的条件分别如下： 主节点：每秒1次调用复制定时函数replicationCron()，在其中判断当前时间距离上次收到各个从节点REPLCONF ACK的时间，是否超过了repl-timeout值，如果超过了则释放相应从节点的连接。 从节点：从节点对超时的判断同样是在复制定时函数中判断，基本逻辑是： 如果当前处于连接建立阶段，且距离上次收到主节点的信息的时间已超过repl-timeout，则释放与主节点的连接； 如果当前处于数据同步阶段，且收到主节点的RDB文件的时间超时，则停止数据同步，释放连接； 如果当前处于命令传播阶段，且距离上次收到主节点的PING命令或数据的时间已超过repl-timeout值，则释放与主节点的连接。 需要注意的坑下面介绍与复制阶段连接超时有关的一些实际问题： 数据同步阶段：在主从节点进行全量复制bgsave时，主节点需要首先fork子进程将当前数据保存到RDB文件中，然后再将RDB文件通过网络传输到从节点。如果RDB文件过大，主节点在fork子进程+保存RDB文件时耗时过多，可能会导致从节点长时间收不到数据而触发超时；此时从节点会重连主节点，然后再次全量复制，再次超时，再次重连……这是个悲伤的循环。为了避免这种情况的发生，除了注意Redis单机数据量不要过大，另一方面就是适当增大repl-timeout值，具体的大小可以根据bgsave耗时来调整。 命令传播阶段：如前所述，在该阶段主节点会向从节点发送PING命令，频率由repl-ping-slave-period控制；该参数应明显小于repl-timeout值(后者至少是前者的几倍)。否则，如果两个参数相等或接近，网络抖动导致个别PING命令丢失，此时恰巧主节点也没有向从节点发送数据，则从节点很容易判断超时。 慢查询导致的阻塞：如果主节点或从节点执行了一些慢查询（如keys *或者对大数据的hgetall等），导致服务器阻塞；阻塞期间无法响应复制连接中对方节点的请求，可能导致复制超时。 复制中断问题主从节点超时是复制中断的原因之一，除此之外，还有其他情况可能导致复制中断，其中最主要的是复制缓冲区溢出问题。 复制缓冲区溢出前面曾提到过，在全量复制阶段，主节点会将执行的写命令放到复制缓冲区中，该缓冲区存放的数据包括了以下几个时间段内主节点执行的写命令：bgsave生成RDB文件、RDB文件由主节点发往从节点、从节点清空老数据并载入RDB文件中的数据。当主节点数据量较大，或者主从节点之间网络延迟较大时，可能导致该缓冲区的大小超过了限制，此时主节点会断开与从节点之间的连接；这种情况可能引起全量复制-&gt;复制缓冲区溢出导致连接中断-&gt;重连-&gt;全量复制-&gt;复制缓冲区溢出导致连接中断……的循环。 复制缓冲区的大小由client-output-buffer-limit slave {hard limit} {soft limit} {soft seconds}配置，默认值为client-output-buffer-limit slave 256MB 64MB 60，其含义是：如果buffer大于256MB，或者连续60s大于64MB，则主节点会断开与该从节点的连接。该参数是可以通过config set命令动态配置的（即不重启Redis也可以生效）。 当复制缓冲区溢出时，主节点打印日志如下所示： 需要注意的是，复制缓冲区是客户端输出缓冲区的一种，主节点会为每一个从节点分别分配复制缓冲区；而复制积压缓冲区则是一个主节点只有一个，无论它有多少个从节点。 各场景下复制的选择及优化技巧在介绍了Redis复制的种种细节之后，现在我们可以来总结一下，在下面常见的场景中，何时使用部分复制，以及需要注意哪些问题。 第一次建立复制 此时全量复制不可避免，但仍有几点需要注意：如果主节点的数据量较大，应该尽量避开流量的高峰期，避免造成阻塞；如果有多个从节点需要建立对主节点的复制，可以考虑将几个从节点错开，避免主节点带宽占用过大。此外，如果从节点过多，也可以调整主从复制的拓扑结构，由一主多从结构变为树状结构（中间的节点既是其主节点的从节点，也是其从节点的主节点）；但使用树状结构应该谨慎：虽然主节点的直接从节点减少，降低了主节点的负担，但是多层从节点的延迟增大，数据一致性变差；且结构复杂，维护相当困难。 主节点重启 主节点重启可以分为两种情况来讨论，一种是故障导致宕机，另一种则是有计划的重启。 主节点宕机 主节点宕机重启后，runid会发生变化，因此不能进行部分复制，只能全量复制。 实际上在主节点宕机的情况下，应进行故障转移处理，将其中的一个从节点升级为主节点，其他从节点从新的主节点进行复制；且故障转移应尽量的自动化，后面文章将要介绍的哨兵便可以进行自动的故障转移。 安全重启：debug reload 在一些场景下，可能希望对主节点进行重启，例如主节点内存碎片率过高，或者希望调整一些只能在启动时调整的参数。如果使用普通的手段重启主节点，会使得runid发生变化，可能导致不必要的全量复制。 为了解决这个问题，Redis提供了debug reload的重启方式：重启后，主节点的runid和offset都不受影响，避免了全量复制。 但debug reload是一柄双刃剑：它会清空当前内存中的数据，重新从RDB文件中加载，这个过程会导致主节点的阻塞，因此也需要谨慎。 从节点重启 从节点宕机重启后，其保存的主节点的runid会丢失，因此即使再次执行slaveof，也无法进行部分复制。 网络中断 如果主从节点之间出现网络问题，造成短时间内网络中断，可以分为多种情况讨论。 第一种情况：网络问题时间极为短暂，只造成了短暂的丢包，主从节点都没有判定超时（未触发repl-timeout）；此时只需要通过REPLCONF ACK来补充丢失的数据即可。 第二种情况：网络问题时间很长，主从节点判断超时（触发了repl-timeout），且丢失的数据过多，超过了复制积压缓冲区所能存储的范围；此时主从节点无法进行部分复制，只能进行全量复制。为了尽可能避免这种情况的发生，应该根据实际情况适当调整复制积压缓冲区的大小；此外及时发现并修复网络中断，也可以减少全量复制。 第三种情况：介于前述两种情况之间，主从节点判断超时，且丢失的数据仍然都在复制积压缓冲区中；此时主从节点可以进行部分复制。 复制相关的配置这一节总结一下与复制有关的配置，说明这些配置的作用、起作用的阶段，以及配置方法等；通过了解这些配置，一方面加深对Redis复制的了解，另一方面掌握这些配置的方法，可以优化Redis的使用，少走坑。 配置大致可以分为主节点相关配置、从节点相关配置以及与主从节点都有关的配置，下面分别说明。 与主从节点都有关的配置 首先介绍最特殊的配置，它决定了该节点是主节点还是从节点： slaveof ：Redis启动时起作用；作用是建立复制关系，开启了该配置的Redis服务器在启动后成为从节点。该注释默认注释掉，即Redis服务器默认都是主节点。 repl-timeout 60：与各个阶段主从节点连接超时判断有关，见前面的介绍。 主节点相关配置 1) repl-diskless-sync no：作用于全量复制阶段，控制主节点是否使用diskless复制（无盘复制）。所谓diskless复制，是指在全量复制时，主节点不再先把数据写入RDB文件，而是直接写入slave的socket中，整个过程中不涉及硬盘；diskless复制在磁盘IO很慢而网速很快时更有优势。需要注意的是，截至Redis3.0，diskless复制处于实验阶段，默认是关闭的。 1) repl-diskless-sync-delay 5：该配置作用于全量复制阶段，当主节点使用diskless复制时，该配置决定主节点向从节点发送之前停顿的时间，单位是秒；只有当diskless复制打开时有效，默认5s。之所以设置停顿时间，是基于以下两个考虑：(1)向slave的socket的传输一旦开始，新连接的slave只能等待当前数据传输结束，才能开始新的数据传输 (2)多个从节点有较大的概率在短时间内建立主从复制。 2) client-output-buffer-limit slave 256MB 64MB 60：与全量复制阶段主节点的缓冲区大小有关，见前面的介绍。 3) repl-disable-tcp-nodelay no：与命令传播阶段的延迟有关，见前面的介绍。 4) masterauth ：与连接建立阶段的身份验证有关，见前面的介绍。 5) repl-ping-slave-period 10：与命令传播阶段主从节点的超时判断有关，见前面的介绍。 6) repl-backlog-size 1mb：复制积压缓冲区的大小，见前面的介绍。 7) repl-backlog-ttl 3600：当主节点没有从节点时，复制积压缓冲区保留的时间，这样当断开的从节点重新连进来时，可以进行全量复制；默认3600s。如果设置为0，则永远不会释放复制积压缓冲区。 8) min-slaves-to-write 3与min-slaves-max-lag 10：规定了主节点的最小从节点数目，及对应的最大延迟，见前面的介绍。 从节点相关配置 1) slave-serve-stale-data yes：与从节点数据陈旧时是否响应客户端命令有关，见前面的介绍。 2) slave-read-only yes：从节点是否只读；默认是只读的。由于从节点开启写操作容易导致主从节点的数据不一致，因此该配置尽量不要修改。 单机内存大小限制实际上在Redis的使用中，限制单机内存大小的因素非常之多，下面总结一下在主从复制中，单机内存过大可能造成的影响： （1）切主：当主节点宕机时，一种常见的容灾策略是将其中一个从节点提升为主节点，并将其他从节点挂载到新的主节点上，此时这些从节点只能进行全量复制；如果Redis单机内存达到10GB，一个从节点的同步时间在几分钟的级别；如果从节点较多，恢复的速度会更慢。如果系统的读负载很高，而这段时间从节点无法提供服务，会对系统造成很大的压力。 （2）从库扩容：如果访问量突然增大，此时希望增加从节点分担读负载，如果数据量过大，从节点同步太慢，难以及时应对访问量的暴增。 （3）缓冲区溢出：（1）和（2）都是从节点可以正常同步的情形（虽然慢），但是如果数据量过大，导致全量复制阶段主节点的复制缓冲区溢出，从而导致复制中断，则主从节点的数据同步会全量复制-&gt;复制缓冲区溢出导致复制中断-&gt;重连-&gt;全量复制-&gt;复制缓冲区溢出导致复制中断……的循环。 （4）超时：如果数据量过大，全量复制阶段主节点fork+保存RDB文件耗时过大，从节点长时间接收不到数据触发超时，主从节点的数据同步同样可能陷入全量复制-&gt;超时导致复制中断-&gt;重连-&gt;全量复制-&gt;超时导致复制中断……的循环。 此外，主节点单机内存除了绝对量不能太大，其占用主机内存的比例也不应过大：最好只使用50%-65%的内存，留下30%-45%的内存用于执行bgsave命令和创建复制缓冲区等。 总结下面回顾一下本文的主要内容： 主从复制的作用：宏观的了解主从复制是为了解决什么样的问题，即数据冗余、故障恢复、读负载均衡等。 主从复制的操作：即slaveof命令。 主从复制的原理：主从复制包括了连接建立阶段、数据同步阶段、命令传播阶段；其中数据同步阶段，有全量复制和部分复制两种数据同步方式；命令传播阶段，主从节点之间有PING和REPLCONF ACK命令互相进行心跳检测。 应用中的问题：包括读写分离的问题（数据不一致问题、数据过期问题、故障切换问题等）、复制超时问题、复制中断问题等，然后总结了主从复制相关的配置，其中repl-timeout、client-output-buffer-limit slave等对解决Redis主从复制中出现的问题可能会有帮助。","link":"/2020/04/10/Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"},{"title":"Mysql主从延迟","text":"","link":"/2020/04/10/Mysql%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F/"},{"title":"解决Mac升级到10.15.4后nginx和mysql无法启动的问题","text":"昨晚将Mac升级后，nginx和mysql无法启动，提示错误如下： 12345yanghang@doit:~/work/study/php/test&gt; nginx -s reloaddyld: Library not loaded: /usr/local/opt/openssl/lib/libssl.1.0.0.dylib Referenced from: /usr/local/bin/nginx Reason: image not foundAbort trap: 6 发现是openssl升级到1.1.1后导致的，原来mysql和nginx依赖的是1.0.0，在将openssl删除后，重新安装后，还是无法使用： 123456789101112yanghang@doit:~/work/study/php/test&gt; brew remove opensslError: Refusing to uninstall /usr/local/Cellar/openssl@1.1/1.1.1fbecause it is required by apr-util, curl-openssl, freetds, glib, libevent, libpq, libssh2, mysql@5.6, nghttp2, nginx, openldap, php@7.3, python, python@2, rtmpdump and wget, which are currently installed.You can override this and force removal with: brew uninstall --ignore-dependencies opensslyanghang@doit:~/work/study/php/test&gt; brew uninstall --ignore-dependencies opensslUninstalling /usr/local/Cellar/openssl@1.1/1.1.1f... (8,057 files, 18MB)openssl@1.1 1.1.1d is still installed.Run `brew uninstall --force openssl@1.1` to remove all versions.yanghang@doit:~/work/study/php/test&gt; brew uninstall --force openssl@1.1Uninstalling openssl@1.1... (7,983 files, 17.9MB)yanghang@doit:~/work/study/php/test&gt; brew install openssl 重新安装后，将openssl重新选择到老版本，然后nginx启动成功了： 12345678910yanghang@doit:~/work/study/php/test&gt; brew switch openssl 1.0.0Error: openssl does not have a version \"1.0.0\" in the Cellar.openssls installed versions: 1.0.2o_2yanghang@doit:~/work/study/php/test&gt; brew switch openssl 1.0.2o_2Cleaning /usr/local/Cellar/openssl/1.0.2o_2yanghang@doit:~/work/study/php/test&gt; brew services restart nginxStopping `nginx`... (might take a while)==&gt; Successfully stopped `nginx` (label: homebrew.mxcl.nginx)==&gt; Successfully started `nginx` (label: homebrew.mxcl.nginx)s 然后再启动mysql的时候，还是启动不了， 1234567891011121314yanghang@doit:~/work/study/php/test&gt; sudo mysql.server startdyld: Library not loaded: /usr/local/opt/openssl/lib/libssl.1.0.0.dylib Referenced from: /usr/local/Cellar/mysql@5.6/5.6.41/bin/my_print_defaults Reason: image not foundStarting MySQL.dyld: Library not loaded: /usr/local/opt/openssl/lib/libssl.1.0.0.dylib Referenced from: /usr/local/Cellar/mysql@5.6/5.6.41/bin/my_print_defaults Reason: image not founddyld: Library not loaded: /usr/local/opt/openssl/lib/libssl.1.0.0.dylib Referenced from: /usr/local/Cellar/mysql@5.6/5.6.41/bin/my_print_defaults Reason: image not found/usr/local/Cellar/mysql@5.6/5.6.41/bin/mysqld_safe: line 183: 24075 Abort trap: 6 nohup /usr/local/Cellar/mysql\\@5.6/5.6.41/bin/mysqld --basedir=/usr/local/Cellar/mysql\\@5.6/5.6.41 --datadir=/usr/local/var/mysql --plugin-dir=/usr/local/Cellar/mysql\\@5.6/5.6.41/lib/plugin --user=mysql --log-error=yh.err --pid-file=/usr/local/var/mysql/yh.pid &lt; /dev/null &gt; /dev/null 2&gt;&amp;1 ERROR! The server quit without updating PID file (/usr/local/var/mysql/yh.pid). 然后查看对应的/usr/local/var/mysql/yh.err 1234567313382 2020-04-13 10:31:22 34937 [Warning] Setting lower_case_table_names=2 because file system for /usr/local/var/mysql/ is case insensitive313383 2020-04-13 10:31:22 34937 [ERROR] Fatal error: Please read &quot;Security&quot; section of the manual to find out how to run mysqld as root!313384313385 2020-04-13 10:31:22 34937 [ERROR] Aborting313386313387 2020-04-13 10:31:22 34937 [Note] Binlog end313388 2020-04-13 10:31:22 34937 [Note] /usr/local/opt/mysql@5.6/bin/mysqld: Shutdown complete 原来不建议已root启动，所以直接执行 12345678yanghang@doit:~/work/study/php/test&gt; mysql.server startStarting MySQL./usr/local/Cellar/mysql@5.6/5.6.41/bin/mysqld_safe: line 138: /usr/local/var/mysql/yh.err: Permission denied/usr/local/Cellar/mysql@5.6/5.6.41/bin/mysqld_safe: line 138: /usr/local/var/mysql/yh.err: Permission denied/usr/local/Cellar/mysql@5.6/5.6.41/bin/mysqld_safe: line 183: /usr/local/var/mysql/yh.err: Permission denied/usr/local/Cellar/mysql@5.6/5.6.41/bin/mysqld_safe: line 138: /usr/local/var/mysql/yh.err: Permission denied ERROR! The server quit without updating PID file (/usr/local/var/mysql/yh.pid). 于是将/usr/local/var/mysql/yh.err权限改了一下，能启动了。done！！！","link":"/2020/04/13/%E8%A7%A3%E5%86%B3Mac%E5%8D%87%E7%BA%A7%E5%88%B010-15-4%E5%90%8Enginx%E5%92%8Cmysql%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"算法题，输出是父的元素以及其所有下属","text":"今天面试有一道算法题，有一个上级和下属的关系数组如下： 1234567891011121314151617181920212223$teams = [ '一'=&gt;[ '三'=&gt;null, '四'=&gt;[ '五'=&gt;null, '六'=&gt;[ '七'=&gt;null, '八'=&gt;null ], ] ], '二'=&gt;[ '九'=&gt;[ '十'=&gt;[ '十一'=&gt;null, '十二'=&gt;[ '十三'=&gt;null, '十四'=&gt;null ], ], ], ]]; 题目让输出所有是是父的下属，如：三没有下属，六有七、八两个下属，让输出如下结果： 一：三,四,五,六,七,八 三： 四：五,六,七,八 五： 六：七,八 七： 八： 二：九,十,十一,十二,十三,十四 九：十,十一,十二,十三,十四 十：十一,十二,十三,十四 十一： 十二：十三,十四 十三： 十四： 看题意应该是递归无疑了，但是比如八这个元素在结果中出现多次，所以一层递归搞不定，最后结果见如下代码（代码直接用截图了，为了让大家也手敲一下，截图用的是vscode的Polacode插件）：","link":"/2020/04/14/%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%8C%E8%BE%93%E5%87%BA%E6%98%AF%E7%88%B6%E7%9A%84%E5%85%83%E7%B4%A0%E4%BB%A5%E5%8F%8A%E5%85%B6%E6%89%80%E6%9C%89%E4%B8%8B%E5%B1%9E/"},{"title":"DNS：我是如何为域名找到家的","text":"","link":"/2020/04/16/DNS%EF%BC%9A%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%89%BE%E5%88%B0%E5%AE%B6%E7%9A%84/"},{"title":"Redis高级数据类型与其应用","text":"","link":"/2020/04/20/Redis%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%85%B6%E5%BA%94%E7%94%A8/"},{"title":"docker下安装ElasticSearch、Kibana、Cerebro","text":"","link":"/2020/04/20/docker%E4%B8%8B%E5%AE%89%E8%A3%85ElasticSearch%E3%80%81Kibana%E3%80%81Cerebro/"}],"tags":[{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"}],"categories":[{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"}]}