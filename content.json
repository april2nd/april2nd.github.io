{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"设计模式二-观察者模式","text":"单例模式是所有设计模式里第一个先讲的模式，相信所有人对单例已经有了解了，所以直接跳过了单例模式的讲解","link":"/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"Markdown模板文件","text":"Markdown是一种轻量级的「标记语言」 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md” MdEditor是一个在线编辑Markdown文档的编辑器MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。 Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 MdEditor源于Pandao的JavaScript开源项目，开源地址Editor.md，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。 MdEditor的功能列表演示标题H1标题H2标题H3标题H4标题H5标题H5字符效果和横线等 删除线 删除线（开启识别HTML标签时） 斜体字 斜体字 粗体 粗体 粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 锚点与链接 Links普通链接普通链接带标题直接链接：https://www.mdeditor.com[锚点链接][anchor-id][anchor-id]: https://www.mdeditor.com/mailto:test.test@gmail.comGFM a-tail link @pandao邮箱地址自动链接 test.test@gmail.com www@vip.qq.com @pandao 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked 缩进风格即缩进四个空格，也做为实现类似 &lt;pre&gt; 预格式化文本 ( Preformatted Text ) 的功能。 &lt;?php echo &quot;Hello world!&quot;; ?&gt;预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell |JS代码123function test() { console.log(\"Hello world!\");} 123&lt;?php echo 'hello world';?&gt; HTML 代码 HTML codes1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=\"utf-8\" /&gt; &lt;meta name=\"keywords\" content=\"Editor.md, Markdown, Editor\" /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type=\"text/css\"&gt; body{font-size:14px;color:#444;font-family: \"Microsoft Yahei\", Tahoma, \"Hiragino Sans GB\", Arial;background:#fff;} ul{list-style: none;} img{border:none;vertical-align: middle;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=\"text-xxl\"&gt;Hello world!&lt;/h1&gt; &lt;p class=\"text-green\"&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 图片 Images图片加链接 (Image + Link)： Follow your heart. 列表 Lists无序列表（减号）Unordered Lists (-) 列表一 列表二 列表三 无序列表（星号）Unordered Lists (*) 列表一 列表二 列表三 无序列表（加号和嵌套）Unordered Lists (+) 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 Ordered Lists (-) 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 First Header Second Header Content Cell Content Cell Content Cell Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell Function name Description help() Display the help window. destroy() Destroy your computer! Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes&copy; &amp; &uml; &trade; &iexcl; &pound;&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo; 18&ordm;C &quot; &apos; [========] Emoji表情 :smiley: Blockquotes :star: GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x: :smiley: @mentions, :smiley: #refs, links, formatting, and tags supported :editormd-logo:; list syntax required (any unordered or ordered list supported) :editormd-logo-3x:; [ ] :smiley: this is a complete item :smiley:; []this is an incomplete item test link :fa-star: @pandao; [ ]this is an incomplete item :fa-star: :fa-gear:; :smiley: this is an incomplete item test link :fa-star: :fa-gear:; :smiley: this is :fa-star: :fa-gear: an incomplete item test link; 反斜杠 Escape*literal asterisks* [========] 科学公式 TeX(KaTeX)$$E=mc^2$$ 行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。 $$x &gt; y$$ $$(\\sqrt{3x-1}+(1+x)^2)$$ $$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$ 多行公式： $$math\\displaystyle\\left( \\sum_{k=1}^n a_k b_k \\right)^2\\leq\\left( \\sum_{k=1}^n a_k^2 \\right)\\left( \\sum_{k=1}^n b_k^2 \\right)$$ $$katex\\displaystyle \\frac{1}{ \\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{ \\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} { 1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$$$latexf(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi),e^{2 \\pi i \\xi x} ,d\\xi$$ 分页符 Page break Print Test: Ctrl + P [========] 绘制流程图 Flowchart12345678st=&gt;start: 用户登陆op=&gt;operation: 登陆操作cond=&gt;condition: 登陆成功 Yes or No?e=&gt;end: 进入后台st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op [========] 绘制序列图 Sequence Diagram1234Andrew-&gt;China: Says HelloNote right of China: China thinks\\nabout itChina--&gt;Andrew: How are you?Andrew-&gt;&gt;China: I am good thanks! End","link":"/2020/04/03/Markdown%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/"},{"title":"PHP7内存管理","text":"内存管理的意义：内存是系统中重要的基本资源之一，内存的管理是指其分配、使用和回收的管理；保障各个程序内存的正常分配和回收。 虽然操作系统以及提供了一套内存管理的函数，但是PHP还是自己实现了一套内存管理方案-PHP内存管理器（Zend Memory Manager简称MM）如下图： 从图中可以看出PHP脚本运行所需内存不是直接从系统调用的，而是先通过内存管理器提供的一系列API接口（zend-mm-alloc-small、alloc-large、alloc-huge等，alloc意思为分配，huge为超大）申请：如果MM中有足够的内存，则直接分配给脚本；如果MM中不够用，则MM再向系统申请。这样可以有效减少PHP向系统调用的次数，并且优化内存空间使用效率。因为C、C++需要手动申请和释放内存，所以其比PHP开发要难。 在此引入一个内存池的概念：提供了一个更有效率的解决方案，即预先规划一定数量的内存区块，使得整个程序可以在运行期规划（allocate）、使用（access）、归还（free）内存区块。一个池子无非就是先占用一块内存，然后给需要的人使用。 内存管理准备知识据PHP 7核心开发者描述，PHP 7在内存管理上的CPU时间节省达到了21%，提升巨大。 PH7其实是借鉴了前辈的内存管理方案：jemalloc和tcmalloc，这两个分别是火狐和chrome两大浏览器的内存管理器。这种内存管理器的内存分配思想大致就是：先申请一大块内存，自己先占着，然后再按照大中小三种规格分割成小块，放在内存池中。当程序申请内存时，MM从池子中挑选合适大小的内存给程序。 基本概念PHP7内存管理器的的代码是在php-7.x.x/Zend/zenc_alloc.c中实现的。它维护了三种规格的内存，分别是chunk、page、slot； 这三种大小是在php-7.x.x/Zend/zenc_alloc_sizes.h中定义的： 123#define ZEND_MM_CHUNK_SIZE (2 * 1024 * 1024) /* 2 MB */#define ZEND_MM_PAGE_SIZE (4 * 1024) /* 4 KB */#define ZEND_MM_PAGES (ZEND_MM_CHUNK_SIZE / ZEND_MM_PAGE_SIZE) /* 512 */ page是在chunk中分配的，那么一个chunk可以分为2MB/4KB=512个page，如图2所示。 在PHP 7中，对于chunk大块内存的申请是使用mmap函数实现的，其中mmap函数原型如下： 12345/* MAP_FIXED leads to discarding of the old mapping, so it can't be used. */void *ptr = mmap(addr, size, PROT_READ | PROT_WRITE, flags /*| MAP_POPULATE | MAP_HUGETLB*/, ZEND_MM_FD, 0);//PHP7中对应的调用如下ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON | MAP_HUGETLB, -1, 0); 各个参数的含义如下： start：映射区开始地址，0表示由系统决定的起始地址，PHP7传入的NULL，也就是0 length：映射区长度，以字节为单位，不足一页时按一页处理 prot：期望的内存保护标志不能与文件的打开方式冲突。prot可以是以下的某个值，且可以使用or将合理的组合在一起： PROT_EXEC：页内容可执行 PROT_READ：页内容可读取 PROT_WRITE：页可以写入 PROT_NONE：页不可访问 PHP7中的为PROT_READ | PROT_WRITE，即可读写 flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个位的组合体，PHP 7使用的是MAP_PRIVATE | MAP_ANON，前者是建立一个写入时复制的私有映射，后者表示匿名映射，映射区不与任何文件关联。 fd：有效的文件描述词。PHP 7中设置为-1，此时需要指定flags参数中的MAP_ANON，表明进行的是匿名映射。 off_toffset：被映射对象内容的起点，PHP 7中设置为0。 PHP 7通过调用mmap函数，返回一大块内存，一般是chunk大小的倍数，后面的内存管理工作在这一大块内存上进行操作。 PHP 7的MM将申请内存按大小分成了3类：small内存、large内存、huge内存。 small内存：小于等于3KB的内存。 large内存：大于3KB且小于等于（2MB-4KB）的内存，可以对应整数倍的page，之所以要减掉4KB一个page的大小，后面会详细展开。 huge内存：大于2MB-4KB的内存，可以直接对应整数倍的chunk。 与mmap相反的操作是int munmap(void *start, size_t length)，用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小，该函数在释放内存的时候使用。 内存对齐在用C/C++进行软件开发、申请内存时，编译器可以帮我们实现内存对齐，虽然看上去浪费了内存，但是提升了CPU访问内存的速度。 对齐举例：在PHP 7的内存池管理中，比如我们申请300B的内存，如果以256B对齐，则对齐后的内存应该是512B（256的2倍）。 PHP7中的内存对齐主要用到一下三个宏 1234567//还是在zend_alloc.c中#define ZEND_MM_ALIGNED_OFFSET(size, alignment) \\ (((size_t)(size)) &amp; ((alignment) - 1))#define ZEND_MM_ALIGNED_BASE(size, alignment) \\ (((size_t)(size)) &amp; ~((alignment) - 1))#define ZEND_MM_SIZE_TO_NUM(size, alignment) \\ (((size_t)(size) + ((alignment) - 1)) / (alignment)) 如何理解这几个宏呢？下面举例来说明一下，假如要申请一个大小为4KB的内存，并以0x1000对齐，如图3所示。 申请0x1000+0x1000-0x0001=0x1fff的内存（也就是多申请0xfff的内存），比如申请到的起始地址为0x103c60120，结束地址为0x103c6211f；因为此时的地址不是0x1000对齐的（因为0x103c60120不是0x1000的整数倍），所以要进行对齐操作。 为了对齐，先释放0x103c60120到0x103c61000（恰好是起始地址和结束地址区间内0x1000的整数倍）的0xee0长度的内存，起始保证了起始地址为0x103c61000，是与0x1000对齐的。 释放0x103c62000到0x103c6211f的0x11f长度内存（两次释放的内存长度0xee0+0x11f=0xfff，恰好为多申请的长度）。 剩下的即为需要的0x1000长度，起始地址为0x103c61000，结束地址为0x103c62000的内存。 使用此内存时，比如有一内存地址为0x103c61120，通过宏计算，可以得出，此内存所在的page的起始地址为0x103c61000，在此page的偏移量为0x120，能够快速定位内存地址所在的page，提高效率。 以上是内存管理的概念和内存对齐方法 内存管理的数据结构PHP7的内存管理用到了一些结构体，其中核心的结构体有zend_mm_heap、zend_mm_page、zend_mm_chunk。其中zend_mm_page最简单，对应的是4KB的char数组，下面对zend_mm_heap和zenc_mm_chunk进行讨论。 _zend_mm_heap以下为_zend_mm_heap的结构体定义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct _zend_mm_heap {#if ZEND_MM_CUSTOM int use_custom_heap;#endif#if ZEND_MM_STORAGE zend_mm_storage *storage;#endif#if ZEND_MM_STAT size_t size; /* current memory usage */ size_t peak; /* peak memory usage */#endif zend_mm_free_slot *free_slot[ZEND_MM_BINS]; /* free lists for small sizes */#if ZEND_MM_STAT || ZEND_MM_LIMIT size_t real_size; /* current size of allocated pages */#endif#if ZEND_MM_STAT size_t real_peak; /* peak size of allocated pages */#endif#if ZEND_MM_LIMIT size_t limit; /* memory limit */ int overflow; /* memory overflow flag */#endif zend_mm_huge_list *huge_list; /* list of huge allocated blocks */ zend_mm_chunk *main_chunk; zend_mm_chunk *cached_chunks; /* list of unused chunks */ int chunks_count; /* number of allocated chunks */ int peak_chunks_count; /* peak number of allocated chunks for current request */ int cached_chunks_count; /* number of cached chunks */ double avg_chunks_count; /* average number of chunks allocated per request */ int last_chunks_delete_boundary; /* numer of chunks after last deletion */ int last_chunks_delete_count; /* number of deletion over the last boundary */#if ZEND_MM_CUSTOM union { struct { void *(*_malloc)(size_t); void (*_free)(void*); void *(*_realloc)(void*, size_t); } std; struct { void *(*_malloc)(size_t ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC); void (*_free)(void* ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC); void *(*_realloc)(void*, size_t ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC); } debug; } custom_heap; HashTable *tracked_allocs;#endif}; 下面解释下变量的含义。 size/real_size：size代表的是MM当前申请的已使用的内存，real_size还包括申请的未使用的内存；可以通过PHP的函数memory_get_usage来获取，其PHP函数原型如下： int memory_get_usage([bool $real_usage = false]) $real_usage默认为false，只返回使用的内存大小；对于true的情况，会返回包括没有使用的分配内存的大小。在PHP7的源码中有对应的实现： 123456789101112ZEND_API size_t zend_memory_usage(int real_usage){#if ZEND_MM_STAT if (real_usage) { return AG(mm_heap)-&gt;real_size; } else { size_t usage = AG(mm_heap)-&gt;size; return usage; }#endif return 0;} 从源码中可以看出参数为true时，返回的是real_size；当为false时，返回的是size；size和real_size会在申请和释放内存时进行修改。 peak/real_peak：peak是emalloc上报的内存峰值，可以通过PHP的函数memory_get_peak_usage来获取，其PHP函数的原型如下：int memory_get_peak_usage([bool $real_usage = false]) $real_usage默认为false，只返回emalloc上报的内存峰值大小；对于true的情况，会返回内存分配峰值的大小；在PHP7的源码中，有对应的实现： 1234567891011ZEND_API size_t zend_memory_peak_usage(int real_usage) { #if ZEND_MM_STAT if (real_usage) { return AG(mm_heap)-&gt;real_peak; } else { return AG(mm_heap)-&gt;peak; } #endif return 0; } 从源码中，可以看出true时返回的是real_peak，同样，在申请和释放内存时real_peak和peak也会进行修改。 free_slot：指针数组 未完待续","link":"/2020/04/05/PHP7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"}],"categories":[{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"}]}